import $iIEVR$fs, {stat as $iIEVR$stat, statSync as $iIEVR$statSync, promises as $iIEVR$promises, openSync as $iIEVR$openSync, readSync as $iIEVR$readSync, closeSync as $iIEVR$closeSync} from "fs";
import {join as $iIEVR$join, delimiter as $iIEVR$delimiter, sep as $iIEVR$sep, posix as $iIEVR$posix, normalize as $iIEVR$normalize, resolve as $iIEVR$resolve} from "path";
import {Buffer as $iIEVR$Buffer} from "node:buffer";
import $iIEVR$nodepath from "node:path";
import $iIEVR$nodechild_process, {ChildProcess as $iIEVR$ChildProcess} from "node:child_process";
import $iIEVR$nodeprocess from "node:process";
import {spawn as $iIEVR$spawn, spawnSync as $iIEVR$spawnSync} from "child_process";
import $iIEVR$nodeurl from "node:url";
import $iIEVR$nodeos, {constants as $iIEVR$constants} from "node:os";
import * as $iIEVR$assert from "assert";
import * as $iIEVR$events from "events";
import {createWriteStream as $iIEVR$createWriteStream, readFileSync as $iIEVR$readFileSync, createReadStream as $iIEVR$createReadStream} from "node:fs";
import {constants as $iIEVR$constants1} from "buffer";
import {pipeline as $iIEVR$pipeline, PassThrough as $iIEVR$PassThrough} from "stream";
import {promisify as $iIEVR$promisify} from "util";
import {debuglog as $iIEVR$debuglog} from "node:util";


function $parcel$interopDefault(a) {
  return a && a.__esModule ? a.default : a;
}

function $parcel$export(e, n, v, s) {
  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});
}

      var $parcel$global =
        typeof globalThis !== 'undefined'
          ? globalThis
          : typeof self !== 'undefined'
          ? self
          : typeof window !== 'undefined'
          ? window
          : typeof global !== 'undefined'
          ? global
          : {};
  
var $parcel$modules = {};
var $parcel$inits = {};

var parcelRequire = $parcel$global["parcelRequireb51e"];

if (parcelRequire == null) {
  parcelRequire = function(id) {
    if (id in $parcel$modules) {
      return $parcel$modules[id].exports;
    }
    if (id in $parcel$inits) {
      var init = $parcel$inits[id];
      delete $parcel$inits[id];
      var module = {id: id, exports: {}};
      $parcel$modules[id] = module;
      init.call(module.exports, module, module.exports);
      return module.exports;
    }
    var err = new Error("Cannot find module '" + id + "'");
    err.code = 'MODULE_NOT_FOUND';
    throw err;
  };

  parcelRequire.register = function register(id, init) {
    $parcel$inits[id] = init;
  };

  $parcel$global["parcelRequireb51e"] = parcelRequire;
}

var parcelRegister = parcelRequire.register;
parcelRegister("6ssbl", function(module, exports) {
module.exports = $4b3b37fa6d624c95$var$isexe;
$4b3b37fa6d624c95$var$isexe.sync = $4b3b37fa6d624c95$var$sync;

function $4b3b37fa6d624c95$var$checkPathExt(path, options) {
    var pathext = options.pathExt !== undefined ? options.pathExt : process.env.PATHEXT;
    if (!pathext) return true;
    pathext = pathext.split(";");
    if (pathext.indexOf("") !== -1) return true;
    for(var i = 0; i < pathext.length; i++){
        var p = pathext[i].toLowerCase();
        if (p && path.substr(-p.length).toLowerCase() === p) return true;
    }
    return false;
}
function $4b3b37fa6d624c95$var$checkStat(stat, path, options) {
    if (!stat.isSymbolicLink() && !stat.isFile()) return false;
    return $4b3b37fa6d624c95$var$checkPathExt(path, options);
}
function $4b3b37fa6d624c95$var$isexe(path, options, cb) {
    $iIEVR$stat(path, function(er, stat) {
        cb(er, er ? false : $4b3b37fa6d624c95$var$checkStat(stat, path, options));
    });
}
function $4b3b37fa6d624c95$var$sync(path, options) {
    return $4b3b37fa6d624c95$var$checkStat($iIEVR$statSync(path), path, options);
}

});

parcelRegister("1vtqQ", function(module, exports) {
module.exports = $118f8443dee3f4fd$var$isexe;
$118f8443dee3f4fd$var$isexe.sync = $118f8443dee3f4fd$var$sync;

function $118f8443dee3f4fd$var$isexe(path, options, cb) {
    $iIEVR$stat(path, function(er, stat) {
        cb(er, er ? false : $118f8443dee3f4fd$var$checkStat(stat, options));
    });
}
function $118f8443dee3f4fd$var$sync(path, options) {
    return $118f8443dee3f4fd$var$checkStat($iIEVR$statSync(path), options);
}
function $118f8443dee3f4fd$var$checkStat(stat, options) {
    return stat.isFile() && $118f8443dee3f4fd$var$checkMode(stat, options);
}
function $118f8443dee3f4fd$var$checkMode(stat, options) {
    var mod = stat.mode;
    var uid = stat.uid;
    var gid = stat.gid;
    var myUid = options.uid !== undefined ? options.uid : process.getuid && process.getuid();
    var myGid = options.gid !== undefined ? options.gid : process.getgid && process.getgid();
    var u = parseInt("100", 8);
    var g = parseInt("010", 8);
    var o = parseInt("001", 8);
    var ug = u | g;
    var ret = mod & o || mod & g && gid === myGid || mod & u && uid === myUid || mod & ug && myUid === 0;
    return ret;
}

});

parcelRegister("6j8hI", function(module, exports) {
// This is not the set of all possible signals.
//
// It IS, however, the set of all signals that trigger
// an exit on either Linux or BSD systems.  Linux is a
// superset of the signal names supported on BSD, and
// the unknown signals just fail to register, so we can
// catch that easily enough.
//
// Don't bother with SIGKILL.  It's uncatchable, which
// means that we can't fire any callbacks anyway.
//
// If a user does happen to register a handler on a non-
// fatal signal like SIGWINCH or something, and then
// exit, it'll end up firing `process.emit('exit')`, so
// the handler will be fired anyway.
//
// SIGBUS, SIGFPE, SIGSEGV and SIGILL, when not raised
// artificially, inherently leave the process in a
// state from which it is not safe to try and enter JS
// listeners.
module.exports = [
    "SIGABRT",
    "SIGALRM",
    "SIGHUP",
    "SIGINT",
    "SIGTERM"
];
if (process.platform !== "win32") module.exports.push("SIGVTALRM", "SIGXCPU", "SIGXFSZ", "SIGUSR2", "SIGTRAP", "SIGSYS", "SIGQUIT", "SIGIOT");
if (process.platform === "linux") module.exports.push("SIGIO", "SIGPOLL", "SIGPWR", "SIGSTKFLT", "SIGUNUSED");

});

var $345f0b38609981b6$exports = {};

$parcel$export($345f0b38609981b6$exports, "hasSudo", () => $345f0b38609981b6$export$7683bf1311d8252);
$parcel$export($345f0b38609981b6$exports, "isRoot", () => $345f0b38609981b6$export$e3140dc7d0c35e48);
$parcel$export($345f0b38609981b6$exports, "isSudo", () => $345f0b38609981b6$export$316200228f28b8ce);
$parcel$export($345f0b38609981b6$exports, "prependSudo", () => $345f0b38609981b6$export$d976d47922ae9667);
$parcel$export($345f0b38609981b6$exports, "defaultExecOptions", () => $345f0b38609981b6$export$151aeb0ade3989e1);
$parcel$export($345f0b38609981b6$exports, "execRootSync", () => $345f0b38609981b6$export$58f152936f209932);
$parcel$export($345f0b38609981b6$exports, "execRoot", () => $345f0b38609981b6$export$351270479e2eef26);
var $2a4ec6ee800b4c3d$exports = {};
var $63e30615774bc4fb$exports = {};

$parcel$export($63e30615774bc4fb$exports, "isexe", () => $63e30615774bc4fb$export$35888d6059c232d4);
$parcel$export($63e30615774bc4fb$exports, "sync", () => $63e30615774bc4fb$export$92d6409d68f0739a);
/**
 * This is the Posix implementation of isexe, which uses the file
 * mode and uid/gid values.
 *
 * @module
 */ 

var $40bd671a45062c29$export$2e2bcd8739ae039 = (0, $iIEVR$promises);
const { access: $40bd671a45062c29$export$9bb0e144ba4929ca, appendFile: $40bd671a45062c29$export$31f54b44f813a103, chmod: $40bd671a45062c29$export$fe07cae62e774a05, chown: $40bd671a45062c29$export$86560bc0b866a003, copyFile: $40bd671a45062c29$export$c763efb2c06e223f, lchmod: $40bd671a45062c29$export$4d4374c7ea08c49f, lchown: $40bd671a45062c29$export$b34a65c440b523a2, link: $40bd671a45062c29$export$9c30223ca0a664fb, lstat: $40bd671a45062c29$export$c29f07eab13966a4, mkdir: $40bd671a45062c29$export$d9fa9670717a639d, mkdtemp: $40bd671a45062c29$export$bb440dc863a3b46a, open: $40bd671a45062c29$export$3ce6949f20cea765, readdir: $40bd671a45062c29$export$b1e07c405f785337, readFile: $40bd671a45062c29$export$72c04af63de9061a, readlink: $40bd671a45062c29$export$3d3ca76659ee9f39, realpath: $40bd671a45062c29$export$9f2c45015a422c45, rename: $40bd671a45062c29$export$7ac989ec0c9c279, rmdir: $40bd671a45062c29$export$3f660f6332b9a01d, stat: $40bd671a45062c29$export$f82f04a91eb6144a, symlink: $40bd671a45062c29$export$ed42c6f39f07f97, truncate: $40bd671a45062c29$export$6a506b36fdea397d, unlink: $40bd671a45062c29$export$5e0808041271ce04, utimes: $40bd671a45062c29$export$d85d919a687a608f, writeFile: $40bd671a45062c29$export$552bfb764b5cd2b4 } = (0, $iIEVR$promises); //# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicHJvbWlzZXMubWpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsic3JjL2NvbXBhdC9mcy9wcm9taXNlcy5tdHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLFFBQVEsRUFBRSxNQUFNLElBQUksQ0FBQTtBQUM3QixlQUFlLFFBQVEsQ0FBQTtBQUV2QixNQUFNLENBQUMsTUFBTSxFQUNYLE1BQU0sRUFDTixVQUFVLEVBQ1YsS0FBSyxFQUNMLEtBQUssRUFDTCxRQUFRLEVBQ1IsTUFBTSxFQUNOLE1BQU0sRUFDTixJQUFJLEVBQ0osS0FBSyxFQUNMLEtBQUssRUFDTCxPQUFPLEVBQ1AsSUFBSSxFQUNKLE9BQU8sRUFDUCxRQUFRLEVBQ1IsUUFBUSxFQUNSLFFBQVEsRUFDUixNQUFNLEVBQ04sS0FBSyxFQUNMLElBQUksRUFDSixPQUFPLEVBQ1AsUUFBUSxFQUNSLE1BQU0sRUFDTixNQUFNLEVBQ04sU0FBUyxHQUNWLEdBQUcsUUFBUSxDQUFBIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgcHJvbWlzZXMgfSBmcm9tIFwiZnNcIlxuZXhwb3J0IGRlZmF1bHQgcHJvbWlzZXNcblxuZXhwb3J0IGNvbnN0IHtcbiAgYWNjZXNzLFxuICBhcHBlbmRGaWxlLFxuICBjaG1vZCxcbiAgY2hvd24sXG4gIGNvcHlGaWxlLFxuICBsY2htb2QsXG4gIGxjaG93bixcbiAgbGluayxcbiAgbHN0YXQsXG4gIG1rZGlyLFxuICBta2R0ZW1wLFxuICBvcGVuLFxuICByZWFkZGlyLFxuICByZWFkRmlsZSxcbiAgcmVhZGxpbmssXG4gIHJlYWxwYXRoLFxuICByZW5hbWUsXG4gIHJtZGlyLFxuICBzdGF0LFxuICBzeW1saW5rLFxuICB0cnVuY2F0ZSxcbiAgdW5saW5rLFxuICB1dGltZXMsXG4gIHdyaXRlRmlsZSxcbn0gPSBwcm9taXNlc1xuIl19


const $63e30615774bc4fb$export$35888d6059c232d4 = async (path, options = {})=>{
    const { ignoreErrors: ignoreErrors = false } = options;
    try {
        return $63e30615774bc4fb$var$checkStat(await (0, $40bd671a45062c29$export$f82f04a91eb6144a)(path), options);
    } catch (e) {
        const er = e;
        if (ignoreErrors || er.code === "EACCES") return false;
        throw er;
    }
};
const $63e30615774bc4fb$export$92d6409d68f0739a = (path, options = {})=>{
    const { ignoreErrors: ignoreErrors = false } = options;
    try {
        return $63e30615774bc4fb$var$checkStat((0, $iIEVR$statSync)(path), options);
    } catch (e) {
        const er = e;
        if (ignoreErrors || er.code === "EACCES") return false;
        throw er;
    }
};
const $63e30615774bc4fb$var$checkStat = (stat, options)=>stat.isFile() && $63e30615774bc4fb$var$checkMode(stat, options);
const $63e30615774bc4fb$var$checkMode = (stat, options)=>{
    const myUid = options.uid ?? process.getuid?.();
    const myGroups = options.groups ?? process.getgroups?.() ?? [];
    const myGid = options.gid ?? process.getgid?.() ?? myGroups[0];
    if (myUid === undefined || myGid === undefined) throw new Error("cannot get uid or gid");
    const groups = new Set([
        myGid,
        ...myGroups
    ]);
    const mod = stat.mode;
    const uid = stat.uid;
    const gid = stat.gid;
    const u = parseInt("100", 8);
    const g = parseInt("010", 8);
    const o = parseInt("001", 8);
    const ug = u | g;
    return !!(mod & o || mod & g && groups.has(gid) || mod & u && uid === myUid || mod & ug && myUid === 0);
};


var $1564f123a8b59fab$exports = {};

$parcel$export($1564f123a8b59fab$exports, "isexe", () => $1564f123a8b59fab$export$35888d6059c232d4);
$parcel$export($1564f123a8b59fab$exports, "sync", () => $1564f123a8b59fab$export$92d6409d68f0739a);
/**
 * This is the Windows implementation of isexe, which uses the file
 * extension and PATHEXT setting.
 *
 * @module
 */ 

const $1564f123a8b59fab$export$35888d6059c232d4 = async (path, options = {})=>{
    const { ignoreErrors: ignoreErrors = false } = options;
    try {
        return $1564f123a8b59fab$var$checkStat(await (0, $40bd671a45062c29$export$f82f04a91eb6144a)(path), path, options);
    } catch (e) {
        const er = e;
        if (ignoreErrors || er.code === "EACCES") return false;
        throw er;
    }
};
const $1564f123a8b59fab$export$92d6409d68f0739a = (path, options = {})=>{
    const { ignoreErrors: ignoreErrors = false } = options;
    try {
        return $1564f123a8b59fab$var$checkStat((0, $iIEVR$statSync)(path), path, options);
    } catch (e) {
        const er = e;
        if (ignoreErrors || er.code === "EACCES") return false;
        throw er;
    }
};
const $1564f123a8b59fab$var$checkPathExt = (path, options)=>{
    const { pathExt: pathExt = process.env.PATHEXT || "" } = options;
    const peSplit = pathExt.split(";");
    if (peSplit.indexOf("") !== -1) return true;
    for(let i = 0; i < peSplit.length; i++){
        const p = peSplit[i].toLowerCase();
        const ext = path.substring(path.length - p.length).toLowerCase();
        if (p && ext === p) return true;
    }
    return false;
};
const $1564f123a8b59fab$var$checkStat = (stat, path, options)=>stat.isFile() && $1564f123a8b59fab$var$checkPathExt(path, options);




const $68e5b1322bd22178$var$platform = process.env._ISEXE_TEST_PLATFORM_ || process.platform;
const $68e5b1322bd22178$var$impl = $68e5b1322bd22178$var$platform === "win32" ? $1564f123a8b59fab$exports : $63e30615774bc4fb$exports;
const $68e5b1322bd22178$export$35888d6059c232d4 = $68e5b1322bd22178$var$impl.isexe;
const $68e5b1322bd22178$export$92d6409d68f0739a = $68e5b1322bd22178$var$impl.sync;


var $2a4ec6ee800b4c3d$require$isexe = $68e5b1322bd22178$export$35888d6059c232d4;
var $2a4ec6ee800b4c3d$require$isexeSync = $68e5b1322bd22178$export$92d6409d68f0739a;

var $2a4ec6ee800b4c3d$require$join = $iIEVR$join;
var $2a4ec6ee800b4c3d$require$delimiter = $iIEVR$delimiter;
var $2a4ec6ee800b4c3d$require$sep = $iIEVR$sep;
var $2a4ec6ee800b4c3d$require$posix = $iIEVR$posix;
const $2a4ec6ee800b4c3d$var$isWindows = process.platform === "win32";
// used to check for slashed in commands passed in. always checks for the posix
// seperator on all platforms, and checks for the current separator when not on
// a posix platform. don't use the isWindows check for this since that is mocked
// in tests but we still need the code to actually work when called. that is also
// why it is ignored from coverage.
/* istanbul ignore next */ const $2a4ec6ee800b4c3d$var$rSlash = new RegExp(`[${$2a4ec6ee800b4c3d$require$posix.sep}${$2a4ec6ee800b4c3d$require$sep === $2a4ec6ee800b4c3d$require$posix.sep ? "" : $2a4ec6ee800b4c3d$require$sep}]`.replace(/(\\)/g, "\\$1"));
const $2a4ec6ee800b4c3d$var$rRel = new RegExp(`^\\.${$2a4ec6ee800b4c3d$var$rSlash.source}`);
const $2a4ec6ee800b4c3d$var$getNotFoundError = (cmd)=>Object.assign(new Error(`not found: ${cmd}`), {
        code: "ENOENT"
    });
const $2a4ec6ee800b4c3d$var$getPathInfo = (cmd, { path: optPath = process.env.PATH, pathExt: optPathExt = process.env.PATHEXT, delimiter: optDelimiter = $2a4ec6ee800b4c3d$require$delimiter })=>{
    // If it has a slash, then we don't bother searching the pathenv.
    // just check the file itself, and that's it.
    const pathEnv = cmd.match($2a4ec6ee800b4c3d$var$rSlash) ? [
        ""
    ] : [
        // windows always checks the cwd first
        ...$2a4ec6ee800b4c3d$var$isWindows ? [
            process.cwd()
        ] : [],
        ...(optPath || /* istanbul ignore next: very unusual */ "").split(optDelimiter)
    ];
    if ($2a4ec6ee800b4c3d$var$isWindows) {
        const pathExtExe = optPathExt || [
            ".EXE",
            ".CMD",
            ".BAT",
            ".COM"
        ].join(optDelimiter);
        const pathExt = pathExtExe.split(optDelimiter).flatMap((item)=>[
                item,
                item.toLowerCase()
            ]);
        if (cmd.includes(".") && pathExt[0] !== "") pathExt.unshift("");
        return {
            pathEnv: pathEnv,
            pathExt: pathExt,
            pathExtExe: pathExtExe
        };
    }
    return {
        pathEnv: pathEnv,
        pathExt: [
            ""
        ]
    };
};
const $2a4ec6ee800b4c3d$var$getPathPart = (raw, cmd)=>{
    const pathPart = /^".*"$/.test(raw) ? raw.slice(1, -1) : raw;
    const prefix = !pathPart && $2a4ec6ee800b4c3d$var$rRel.test(cmd) ? cmd.slice(0, 2) : "";
    return prefix + $2a4ec6ee800b4c3d$require$join(pathPart, cmd);
};
const $2a4ec6ee800b4c3d$var$which = async (cmd, opt = {})=>{
    const { pathEnv: pathEnv, pathExt: pathExt, pathExtExe: pathExtExe } = $2a4ec6ee800b4c3d$var$getPathInfo(cmd, opt);
    const found = [];
    for (const envPart of pathEnv){
        const p = $2a4ec6ee800b4c3d$var$getPathPart(envPart, cmd);
        for (const ext of pathExt){
            const withExt = p + ext;
            const is = await $2a4ec6ee800b4c3d$require$isexe(withExt, {
                pathExt: pathExtExe,
                ignoreErrors: true
            });
            if (is) {
                if (!opt.all) return withExt;
                found.push(withExt);
            }
        }
    }
    if (opt.all && found.length) return found;
    if (opt.nothrow) return null;
    throw $2a4ec6ee800b4c3d$var$getNotFoundError(cmd);
};
const $2a4ec6ee800b4c3d$var$whichSync = (cmd, opt = {})=>{
    const { pathEnv: pathEnv, pathExt: pathExt, pathExtExe: pathExtExe } = $2a4ec6ee800b4c3d$var$getPathInfo(cmd, opt);
    const found = [];
    for (const pathEnvPart of pathEnv){
        const p = $2a4ec6ee800b4c3d$var$getPathPart(pathEnvPart, cmd);
        for (const ext of pathExt){
            const withExt = p + ext;
            const is = $2a4ec6ee800b4c3d$require$isexeSync(withExt, {
                pathExt: pathExtExe,
                ignoreErrors: true
            });
            if (is) {
                if (!opt.all) return withExt;
                found.push(withExt);
            }
        }
    }
    if (opt.all && found.length) return found;
    if (opt.nothrow) return null;
    throw $2a4ec6ee800b4c3d$var$getNotFoundError(cmd);
};
$2a4ec6ee800b4c3d$exports = $2a4ec6ee800b4c3d$var$which;
$2a4ec6ee800b4c3d$var$which.sync = $2a4ec6ee800b4c3d$var$whichSync;






var $daf72ea6e4bc8475$exports = {};
"use strict";

var $c130c6d10fe44d87$exports = {};
"use strict";

var $88d18c7637b76847$exports = {};
"use strict";

var $f96dd009f5f00222$exports = {};
const $f96dd009f5f00222$var$isWindows = process.platform === "win32" || process.env.OSTYPE === "cygwin" || process.env.OSTYPE === "msys";

const $f96dd009f5f00222$var$COLON = $f96dd009f5f00222$var$isWindows ? ";" : ":";
var $0d8d6eb9e3382bd4$exports = {};

var $0d8d6eb9e3382bd4$var$core;


if (process.platform === "win32" || $parcel$global.TESTING_WINDOWS) $0d8d6eb9e3382bd4$var$core = (parcelRequire("6ssbl"));
else $0d8d6eb9e3382bd4$var$core = (parcelRequire("1vtqQ"));
$0d8d6eb9e3382bd4$exports = $0d8d6eb9e3382bd4$var$isexe;
$0d8d6eb9e3382bd4$var$isexe.sync = $0d8d6eb9e3382bd4$var$sync;
function $0d8d6eb9e3382bd4$var$isexe(path, options, cb) {
    if (typeof options === "function") {
        cb = options;
        options = {};
    }
    if (!cb) {
        if (typeof Promise !== "function") throw new TypeError("callback not provided");
        return new Promise(function(resolve, reject) {
            $0d8d6eb9e3382bd4$var$isexe(path, options || {}, function(er, is) {
                if (er) reject(er);
                else resolve(is);
            });
        });
    }
    $0d8d6eb9e3382bd4$var$core(path, options || {}, function(er, is) {
        // ignore EACCES because that just means we aren't allowed to run it
        if (er) {
            if (er.code === "EACCES" || options && options.ignoreErrors) {
                er = null;
                is = false;
            }
        }
        cb(er, is);
    });
}
function $0d8d6eb9e3382bd4$var$sync(path, options) {
    // my kingdom for a filtered catch
    try {
        return $0d8d6eb9e3382bd4$var$core.sync(path, options || {});
    } catch (er) {
        if (options && options.ignoreErrors || er.code === "EACCES") return false;
        else throw er;
    }
}


const $f96dd009f5f00222$var$getNotFoundError = (cmd)=>Object.assign(new Error(`not found: ${cmd}`), {
        code: "ENOENT"
    });
const $f96dd009f5f00222$var$getPathInfo = (cmd, opt)=>{
    const colon = opt.colon || $f96dd009f5f00222$var$COLON;
    // If it has a slash, then we don't bother searching the pathenv.
    // just check the file itself, and that's it.
    const pathEnv = cmd.match(/\//) || $f96dd009f5f00222$var$isWindows && cmd.match(/\\/) ? [
        ""
    ] : [
        // windows always checks the cwd first
        ...$f96dd009f5f00222$var$isWindows ? [
            process.cwd()
        ] : [],
        ...(opt.path || process.env.PATH || /* istanbul ignore next: very unusual */ "").split(colon)
    ];
    const pathExtExe = $f96dd009f5f00222$var$isWindows ? opt.pathExt || process.env.PATHEXT || ".EXE;.CMD;.BAT;.COM" : "";
    const pathExt = $f96dd009f5f00222$var$isWindows ? pathExtExe.split(colon) : [
        ""
    ];
    if ($f96dd009f5f00222$var$isWindows) {
        if (cmd.indexOf(".") !== -1 && pathExt[0] !== "") pathExt.unshift("");
    }
    return {
        pathEnv: pathEnv,
        pathExt: pathExt,
        pathExtExe: pathExtExe
    };
};
const $f96dd009f5f00222$var$which = (cmd, opt, cb)=>{
    if (typeof opt === "function") {
        cb = opt;
        opt = {};
    }
    if (!opt) opt = {};
    const { pathEnv: pathEnv, pathExt: pathExt, pathExtExe: pathExtExe } = $f96dd009f5f00222$var$getPathInfo(cmd, opt);
    const found = [];
    const step = (i)=>new Promise((resolve, reject)=>{
            if (i === pathEnv.length) return opt.all && found.length ? resolve(found) : reject($f96dd009f5f00222$var$getNotFoundError(cmd));
            const ppRaw = pathEnv[i];
            const pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw;
            const pCmd = $iIEVR$join(pathPart, cmd);
            const p = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd;
            resolve(subStep(p, i, 0));
        });
    const subStep = (p, i, ii)=>new Promise((resolve, reject)=>{
            if (ii === pathExt.length) return resolve(step(i + 1));
            const ext = pathExt[ii];
            $0d8d6eb9e3382bd4$exports(p + ext, {
                pathExt: pathExtExe
            }, (er, is)=>{
                if (!er && is) {
                    if (opt.all) found.push(p + ext);
                    else return resolve(p + ext);
                }
                return resolve(subStep(p, i, ii + 1));
            });
        });
    return cb ? step(0).then((res)=>cb(null, res), cb) : step(0);
};
const $f96dd009f5f00222$var$whichSync = (cmd, opt)=>{
    opt = opt || {};
    const { pathEnv: pathEnv, pathExt: pathExt, pathExtExe: pathExtExe } = $f96dd009f5f00222$var$getPathInfo(cmd, opt);
    const found = [];
    for(let i = 0; i < pathEnv.length; i++){
        const ppRaw = pathEnv[i];
        const pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw;
        const pCmd = $iIEVR$join(pathPart, cmd);
        const p = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd;
        for(let j = 0; j < pathExt.length; j++){
            const cur = p + pathExt[j];
            try {
                const is = $0d8d6eb9e3382bd4$exports.sync(cur, {
                    pathExt: pathExtExe
                });
                if (is) {
                    if (opt.all) found.push(cur);
                    else return cur;
                }
            } catch (ex) {}
        }
    }
    if (opt.all && found.length) return found;
    if (opt.nothrow) return null;
    throw $f96dd009f5f00222$var$getNotFoundError(cmd);
};
$f96dd009f5f00222$exports = $f96dd009f5f00222$var$which;
$f96dd009f5f00222$var$which.sync = $f96dd009f5f00222$var$whichSync;


var $33700fc17480ef92$exports = {};
"use strict";
const $33700fc17480ef92$var$pathKey = (options = {})=>{
    const environment = options.env || process.env;
    const platform = options.platform || process.platform;
    if (platform !== "win32") return "PATH";
    return Object.keys(environment).reverse().find((key)=>key.toUpperCase() === "PATH") || "Path";
};
$33700fc17480ef92$exports = $33700fc17480ef92$var$pathKey;
// TODO: Remove this for the next major release
$33700fc17480ef92$exports.default = $33700fc17480ef92$var$pathKey;


function $88d18c7637b76847$var$resolveCommandAttempt(parsed, withoutPathExt) {
    const env = parsed.options.env || process.env;
    const cwd = process.cwd();
    const hasCustomCwd = parsed.options.cwd != null;
    // Worker threads do not have process.chdir()
    const shouldSwitchCwd = hasCustomCwd && process.chdir !== undefined && !process.chdir.disabled;
    // If a custom `cwd` was specified, we need to change the process cwd
    // because `which` will do stat calls but does not support a custom cwd
    if (shouldSwitchCwd) try {
        process.chdir(parsed.options.cwd);
    } catch (err) {
    /* Empty */ }
    let resolved;
    try {
        resolved = $f96dd009f5f00222$exports.sync(parsed.command, {
            path: env[$33700fc17480ef92$exports({
                env: env
            })],
            pathExt: withoutPathExt ? $iIEVR$delimiter : undefined
        });
    } catch (e) {
    /* Empty */ } finally{
        if (shouldSwitchCwd) process.chdir(cwd);
    }
    // If we successfully resolved, ensure that an absolute path is returned
    // Note that when a custom `cwd` was used, we need to resolve to an absolute path based on it
    if (resolved) resolved = $iIEVR$resolve(hasCustomCwd ? parsed.options.cwd : "", resolved);
    return resolved;
}
function $88d18c7637b76847$var$resolveCommand(parsed) {
    return $88d18c7637b76847$var$resolveCommandAttempt(parsed) || $88d18c7637b76847$var$resolveCommandAttempt(parsed, true);
}
$88d18c7637b76847$exports = $88d18c7637b76847$var$resolveCommand;


var $280b98749b8ad9e8$export$ae50443ffc990749;
var $280b98749b8ad9e8$export$6ea29ee575e3f5ff;
"use strict";
// See http://www.robvanderwoude.com/escapechars.php
const $280b98749b8ad9e8$var$metaCharsRegExp = /([()\][%!^"`<>&|;, *?])/g;
function $280b98749b8ad9e8$var$escapeCommand(arg) {
    // Escape meta chars
    arg = arg.replace($280b98749b8ad9e8$var$metaCharsRegExp, "^$1");
    return arg;
}
function $280b98749b8ad9e8$var$escapeArgument(arg, doubleEscapeMetaChars) {
    // Convert to string
    arg = `${arg}`;
    // Algorithm below is based on https://qntm.org/cmd
    // Sequence of backslashes followed by a double quote:
    // double up all the backslashes and escape the double quote
    arg = arg.replace(/(\\*)"/g, '$1$1\\"');
    // Sequence of backslashes followed by the end of the string
    // (which will become a double quote later):
    // double up all the backslashes
    arg = arg.replace(/(\\*)$/, "$1$1");
    // All other backslashes occur literally
    // Quote the whole thing:
    arg = `"${arg}"`;
    // Escape meta chars
    arg = arg.replace($280b98749b8ad9e8$var$metaCharsRegExp, "^$1");
    // Double escape meta chars if necessary
    if (doubleEscapeMetaChars) arg = arg.replace($280b98749b8ad9e8$var$metaCharsRegExp, "^$1");
    return arg;
}
$280b98749b8ad9e8$export$ae50443ffc990749 = $280b98749b8ad9e8$var$escapeCommand;
$280b98749b8ad9e8$export$6ea29ee575e3f5ff = $280b98749b8ad9e8$var$escapeArgument;


var $24099d3b62d0edeb$exports = {};
"use strict";

var $6b556c343e41eb9a$exports = {};
"use strict";
var $8fec7f122efb0741$exports = {};
"use strict";
$8fec7f122efb0741$exports = /^#!(.*)/;


$6b556c343e41eb9a$exports = (string = "")=>{
    const match = string.match($8fec7f122efb0741$exports);
    if (!match) return null;
    const [path, argument] = match[0].replace(/#! ?/, "").split(" ");
    const binary = path.split("/").pop();
    if (binary === "env") return argument;
    return argument ? `${binary} ${argument}` : binary;
};


function $24099d3b62d0edeb$var$readShebang(command) {
    // Read the first 150 bytes from the file
    const size = 150;
    const buffer = Buffer.alloc(size);
    let fd;
    try {
        fd = $iIEVR$openSync(command, "r");
        $iIEVR$readSync(fd, buffer, 0, size, 0);
        $iIEVR$closeSync(fd);
    } catch (e) {}
    // Attempt to extract shebang (null is returned if not a shebang)
    return $6b556c343e41eb9a$exports(buffer.toString());
}
$24099d3b62d0edeb$exports = $24099d3b62d0edeb$var$readShebang;


const $c130c6d10fe44d87$var$isWin = process.platform === "win32";
const $c130c6d10fe44d87$var$isExecutableRegExp = /\.(?:com|exe)$/i;
const $c130c6d10fe44d87$var$isCmdShimRegExp = /node_modules[\\/].bin[\\/][^\\/]+\.cmd$/i;
function $c130c6d10fe44d87$var$detectShebang(parsed) {
    parsed.file = $88d18c7637b76847$exports(parsed);
    const shebang = parsed.file && $24099d3b62d0edeb$exports(parsed.file);
    if (shebang) {
        parsed.args.unshift(parsed.file);
        parsed.command = shebang;
        return $88d18c7637b76847$exports(parsed);
    }
    return parsed.file;
}
function $c130c6d10fe44d87$var$parseNonShell(parsed) {
    if (!$c130c6d10fe44d87$var$isWin) return parsed;
    // Detect & add support for shebangs
    const commandFile = $c130c6d10fe44d87$var$detectShebang(parsed);
    // We don't need a shell if the command filename is an executable
    const needsShell = !$c130c6d10fe44d87$var$isExecutableRegExp.test(commandFile);
    // If a shell is required, use cmd.exe and take care of escaping everything correctly
    // Note that `forceShell` is an hidden option used only in tests
    if (parsed.options.forceShell || needsShell) {
        // Need to double escape meta chars if the command is a cmd-shim located in `node_modules/.bin/`
        // The cmd-shim simply calls execute the package bin file with NodeJS, proxying any argument
        // Because the escape of metachars with ^ gets interpreted when the cmd.exe is first called,
        // we need to double escape them
        const needsDoubleEscapeMetaChars = $c130c6d10fe44d87$var$isCmdShimRegExp.test(commandFile);
        // Normalize posix paths into OS compatible paths (e.g.: foo/bar -> foo\bar)
        // This is necessary otherwise it will always fail with ENOENT in those cases
        parsed.command = $iIEVR$normalize(parsed.command);
        // Escape command & arguments
        parsed.command = $280b98749b8ad9e8$export$ae50443ffc990749(parsed.command);
        parsed.args = parsed.args.map((arg)=>$280b98749b8ad9e8$export$6ea29ee575e3f5ff(arg, needsDoubleEscapeMetaChars));
        const shellCommand = [
            parsed.command
        ].concat(parsed.args).join(" ");
        parsed.args = [
            "/d",
            "/s",
            "/c",
            `"${shellCommand}"`
        ];
        parsed.command = process.env.comspec || "cmd.exe";
        parsed.options.windowsVerbatimArguments = true; // Tell node's spawn that the arguments are already escaped
    }
    return parsed;
}
function $c130c6d10fe44d87$var$parse(command, args, options) {
    // Normalize arguments, similar to nodejs
    if (args && !Array.isArray(args)) {
        options = args;
        args = null;
    }
    args = args ? args.slice(0) : []; // Clone array to avoid changing the original
    options = Object.assign({}, options); // Clone object to avoid changing the original
    // Build our parsed object
    const parsed = {
        command: command,
        args: args,
        options: options,
        file: undefined,
        original: {
            command: command,
            args: args
        }
    };
    // Delegate further parsing to shell or non-shell
    return options.shell ? parsed : $c130c6d10fe44d87$var$parseNonShell(parsed);
}
$c130c6d10fe44d87$exports = $c130c6d10fe44d87$var$parse;


var $948d4846584ad699$exports = {};
"use strict";
const $948d4846584ad699$var$isWin = process.platform === "win32";
function $948d4846584ad699$var$notFoundError(original, syscall) {
    return Object.assign(new Error(`${syscall} ${original.command} ENOENT`), {
        code: "ENOENT",
        errno: "ENOENT",
        syscall: `${syscall} ${original.command}`,
        path: original.command,
        spawnargs: original.args
    });
}
function $948d4846584ad699$var$hookChildProcess(cp, parsed) {
    if (!$948d4846584ad699$var$isWin) return;
    const originalEmit = cp.emit;
    cp.emit = function(name, arg1) {
        // If emitting "exit" event and exit code is 1, we need to check if
        // the command exists and emit an "error" instead
        // See https://github.com/IndigoUnited/node-cross-spawn/issues/16
        if (name === "exit") {
            const err = $948d4846584ad699$var$verifyENOENT(arg1, parsed, "spawn");
            if (err) return originalEmit.call(cp, "error", err);
        }
        return originalEmit.apply(cp, arguments); // eslint-disable-line prefer-rest-params
    };
}
function $948d4846584ad699$var$verifyENOENT(status, parsed) {
    if ($948d4846584ad699$var$isWin && status === 1 && !parsed.file) return $948d4846584ad699$var$notFoundError(parsed.original, "spawn");
    return null;
}
function $948d4846584ad699$var$verifyENOENTSync(status, parsed) {
    if ($948d4846584ad699$var$isWin && status === 1 && !parsed.file) return $948d4846584ad699$var$notFoundError(parsed.original, "spawnSync");
    return null;
}
$948d4846584ad699$exports = {
    hookChildProcess: $948d4846584ad699$var$hookChildProcess,
    verifyENOENT: $948d4846584ad699$var$verifyENOENT,
    verifyENOENTSync: $948d4846584ad699$var$verifyENOENTSync,
    notFoundError: $948d4846584ad699$var$notFoundError
};


function $daf72ea6e4bc8475$var$spawn(command, args, options) {
    // Parse the arguments
    const parsed = $c130c6d10fe44d87$exports(command, args, options);
    // Spawn the child process
    const spawned = $iIEVR$spawn(parsed.command, parsed.args, parsed.options);
    // Hook into child process "exit" event to emit an error if the command
    // does not exists, see: https://github.com/IndigoUnited/node-cross-spawn/issues/16
    $948d4846584ad699$exports.hookChildProcess(spawned, parsed);
    return spawned;
}
function $daf72ea6e4bc8475$var$spawnSync(command, args, options) {
    // Parse the arguments
    const parsed = $c130c6d10fe44d87$exports(command, args, options);
    // Spawn the child process
    const result = $iIEVR$spawnSync(parsed.command, parsed.args, parsed.options);
    // Analyze if the command does not exist, see: https://github.com/IndigoUnited/node-cross-spawn/issues/16
    result.error = result.error || $948d4846584ad699$exports.verifyENOENTSync(result.status, parsed);
    return result;
}
$daf72ea6e4bc8475$exports = $daf72ea6e4bc8475$var$spawn;
$daf72ea6e4bc8475$exports.spawn = $daf72ea6e4bc8475$var$spawn;
$daf72ea6e4bc8475$exports.sync = $daf72ea6e4bc8475$var$spawnSync;
$daf72ea6e4bc8475$exports._parse = $c130c6d10fe44d87$exports;
$daf72ea6e4bc8475$exports._enoent = $948d4846584ad699$exports;


function $11f7c326e148db82$export$2e2bcd8739ae039(input) {
    const LF = typeof input === "string" ? "\n" : "\n".charCodeAt();
    const CR = typeof input === "string" ? "\r" : "\r".charCodeAt();
    if (input[input.length - 1] === LF) input = input.slice(0, -1);
    if (input[input.length - 1] === CR) input = input.slice(0, -1);
    return input;
}





function $063e839e189620b0$export$2e2bcd8739ae039(options = {}) {
    const { env: env = process.env, platform: platform = process.platform } = options;
    if (platform !== "win32") return "PATH";
    return Object.keys(env).reverse().find((key)=>key.toUpperCase() === "PATH") || "Path";
}


function $68ba7b3258eed759$export$62a298cbef08d65c(options = {}) {
    const { cwd: cwd = (0, $iIEVR$nodeprocess).cwd(), path: path_ = (0, $iIEVR$nodeprocess).env[(0, $063e839e189620b0$export$2e2bcd8739ae039)()], execPath: execPath = (0, $iIEVR$nodeprocess).execPath } = options;
    let previous;
    const execPathString = execPath instanceof URL ? (0, $iIEVR$nodeurl).fileURLToPath(execPath) : execPath;
    const cwdString = cwd instanceof URL ? (0, $iIEVR$nodeurl).fileURLToPath(cwd) : cwd;
    let cwdPath = (0, $iIEVR$nodepath).resolve(cwdString);
    const result = [];
    while(previous !== cwdPath){
        result.push((0, $iIEVR$nodepath).join(cwdPath, "node_modules/.bin"));
        previous = cwdPath;
        cwdPath = (0, $iIEVR$nodepath).resolve(cwdPath, "..");
    }
    // Ensure the running `node` binary is used.
    result.push((0, $iIEVR$nodepath).resolve(cwdString, execPathString, ".."));
    return [
        ...result,
        path_
    ].join((0, $iIEVR$nodepath).delimiter);
}
function $68ba7b3258eed759$export$340e1fbaac04248b({ env: env = (0, $iIEVR$nodeprocess).env, ...options } = {}) {
    env = {
        ...env
    };
    const path = (0, $063e839e189620b0$export$2e2bcd8739ae039)({
        env: env
    });
    options.path = env[path];
    env[path] = $68ba7b3258eed759$export$62a298cbef08d65c(options);
    return env;
}


const $57c034a0dbbfd310$var$copyProperty = (to, from, property, ignoreNonConfigurable)=>{
    // `Function#length` should reflect the parameters of `to` not `from` since we keep its body.
    // `Function#prototype` is non-writable and non-configurable so can never be modified.
    if (property === "length" || property === "prototype") return;
    // `Function#arguments` and `Function#caller` should not be copied. They were reported to be present in `Reflect.ownKeys` for some devices in React Native (#41), so we explicitly ignore them here.
    if (property === "arguments" || property === "caller") return;
    const toDescriptor = Object.getOwnPropertyDescriptor(to, property);
    const fromDescriptor = Object.getOwnPropertyDescriptor(from, property);
    if (!$57c034a0dbbfd310$var$canCopyProperty(toDescriptor, fromDescriptor) && ignoreNonConfigurable) return;
    Object.defineProperty(to, property, fromDescriptor);
};
// `Object.defineProperty()` throws if the property exists, is not configurable and either:
// - one its descriptors is changed
// - it is non-writable and its value is changed
const $57c034a0dbbfd310$var$canCopyProperty = function(toDescriptor, fromDescriptor) {
    return toDescriptor === undefined || toDescriptor.configurable || toDescriptor.writable === fromDescriptor.writable && toDescriptor.enumerable === fromDescriptor.enumerable && toDescriptor.configurable === fromDescriptor.configurable && (toDescriptor.writable || toDescriptor.value === fromDescriptor.value);
};
const $57c034a0dbbfd310$var$changePrototype = (to, from)=>{
    const fromPrototype = Object.getPrototypeOf(from);
    if (fromPrototype === Object.getPrototypeOf(to)) return;
    Object.setPrototypeOf(to, fromPrototype);
};
const $57c034a0dbbfd310$var$wrappedToString = (withName, fromBody)=>`/* Wrapped ${withName}*/\n${fromBody}`;
const $57c034a0dbbfd310$var$toStringDescriptor = Object.getOwnPropertyDescriptor(Function.prototype, "toString");
const $57c034a0dbbfd310$var$toStringName = Object.getOwnPropertyDescriptor(Function.prototype.toString, "name");
// We call `from.toString()` early (not lazily) to ensure `from` can be garbage collected.
// We use `bind()` instead of a closure for the same reason.
// Calling `from.toString()` early also allows caching it in case `to.toString()` is called several times.
const $57c034a0dbbfd310$var$changeToString = (to, from, name)=>{
    const withName = name === "" ? "" : `with ${name.trim()}() `;
    const newToString = $57c034a0dbbfd310$var$wrappedToString.bind(null, withName, from.toString());
    // Ensure `to.toString.toString` is non-enumerable and has the same `same`
    Object.defineProperty(newToString, "name", $57c034a0dbbfd310$var$toStringName);
    Object.defineProperty(to, "toString", {
        ...$57c034a0dbbfd310$var$toStringDescriptor,
        value: newToString
    });
};
function $57c034a0dbbfd310$export$2e2bcd8739ae039(to, from, { ignoreNonConfigurable: ignoreNonConfigurable = false } = {}) {
    const { name: name } = to;
    for (const property of Reflect.ownKeys(from))$57c034a0dbbfd310$var$copyProperty(to, from, property, ignoreNonConfigurable);
    $57c034a0dbbfd310$var$changePrototype(to, from);
    $57c034a0dbbfd310$var$changeToString(to, from, name);
    return to;
}


const $8f2127b429579d4b$var$calledFunctions = new WeakMap();
const $8f2127b429579d4b$var$onetime = (function_, options = {})=>{
    if (typeof function_ !== "function") throw new TypeError("Expected a function");
    let returnValue;
    let callCount = 0;
    const functionName = function_.displayName || function_.name || "<anonymous>";
    const onetime = function(...arguments_) {
        $8f2127b429579d4b$var$calledFunctions.set(onetime, ++callCount);
        if (callCount === 1) {
            returnValue = function_.apply(this, arguments_);
            function_ = null;
        } else if (options.throw === true) throw new Error(`Function \`${functionName}\` can only be called once`);
        return returnValue;
    };
    (0, $57c034a0dbbfd310$export$2e2bcd8739ae039)(onetime, function_);
    $8f2127b429579d4b$var$calledFunctions.set(onetime, callCount);
    return onetime;
};
$8f2127b429579d4b$var$onetime.callCount = (function_)=>{
    if (!$8f2127b429579d4b$var$calledFunctions.has(function_)) throw new Error(`The given function \`${function_.name}\` is not wrapped by the \`onetime\` package`);
    return $8f2127b429579d4b$var$calledFunctions.get(function_);
};
var $8f2127b429579d4b$export$2e2bcd8739ae039 = $8f2127b429579d4b$var$onetime;




const $80e7969f4cf1b9d6$export$e221a98f4fd84d36 = ()=>{
    const length = $80e7969f4cf1b9d6$export$dc8812f2f8882ff4 - $80e7969f4cf1b9d6$var$SIGRTMIN + 1;
    return Array.from({
        length: length
    }, $80e7969f4cf1b9d6$var$getRealtimeSignal);
};
const $80e7969f4cf1b9d6$var$getRealtimeSignal = (value, index)=>({
        name: `SIGRT${index + 1}`,
        number: $80e7969f4cf1b9d6$var$SIGRTMIN + index,
        action: "terminate",
        description: "Application-specific signal (realtime)",
        standard: "posix"
    });
const $80e7969f4cf1b9d6$var$SIGRTMIN = 34;
const $80e7969f4cf1b9d6$export$dc8812f2f8882ff4 = 64;



const $58ec265091710a29$export$a43bf6822cc694af = [
    {
        name: "SIGHUP",
        number: 1,
        action: "terminate",
        description: "Terminal closed",
        standard: "posix"
    },
    {
        name: "SIGINT",
        number: 2,
        action: "terminate",
        description: "User interruption with CTRL-C",
        standard: "ansi"
    },
    {
        name: "SIGQUIT",
        number: 3,
        action: "core",
        description: "User interruption with CTRL-\\",
        standard: "posix"
    },
    {
        name: "SIGILL",
        number: 4,
        action: "core",
        description: "Invalid machine instruction",
        standard: "ansi"
    },
    {
        name: "SIGTRAP",
        number: 5,
        action: "core",
        description: "Debugger breakpoint",
        standard: "posix"
    },
    {
        name: "SIGABRT",
        number: 6,
        action: "core",
        description: "Aborted",
        standard: "ansi"
    },
    {
        name: "SIGIOT",
        number: 6,
        action: "core",
        description: "Aborted",
        standard: "bsd"
    },
    {
        name: "SIGBUS",
        number: 7,
        action: "core",
        description: "Bus error due to misaligned, non-existing address or paging error",
        standard: "bsd"
    },
    {
        name: "SIGEMT",
        number: 7,
        action: "terminate",
        description: "Command should be emulated but is not implemented",
        standard: "other"
    },
    {
        name: "SIGFPE",
        number: 8,
        action: "core",
        description: "Floating point arithmetic error",
        standard: "ansi"
    },
    {
        name: "SIGKILL",
        number: 9,
        action: "terminate",
        description: "Forced termination",
        standard: "posix",
        forced: true
    },
    {
        name: "SIGUSR1",
        number: 10,
        action: "terminate",
        description: "Application-specific signal",
        standard: "posix"
    },
    {
        name: "SIGSEGV",
        number: 11,
        action: "core",
        description: "Segmentation fault",
        standard: "ansi"
    },
    {
        name: "SIGUSR2",
        number: 12,
        action: "terminate",
        description: "Application-specific signal",
        standard: "posix"
    },
    {
        name: "SIGPIPE",
        number: 13,
        action: "terminate",
        description: "Broken pipe or socket",
        standard: "posix"
    },
    {
        name: "SIGALRM",
        number: 14,
        action: "terminate",
        description: "Timeout or timer",
        standard: "posix"
    },
    {
        name: "SIGTERM",
        number: 15,
        action: "terminate",
        description: "Termination",
        standard: "ansi"
    },
    {
        name: "SIGSTKFLT",
        number: 16,
        action: "terminate",
        description: "Stack is empty or overflowed",
        standard: "other"
    },
    {
        name: "SIGCHLD",
        number: 17,
        action: "ignore",
        description: "Child process terminated, paused or unpaused",
        standard: "posix"
    },
    {
        name: "SIGCLD",
        number: 17,
        action: "ignore",
        description: "Child process terminated, paused or unpaused",
        standard: "other"
    },
    {
        name: "SIGCONT",
        number: 18,
        action: "unpause",
        description: "Unpaused",
        standard: "posix",
        forced: true
    },
    {
        name: "SIGSTOP",
        number: 19,
        action: "pause",
        description: "Paused",
        standard: "posix",
        forced: true
    },
    {
        name: "SIGTSTP",
        number: 20,
        action: "pause",
        description: 'Paused using CTRL-Z or "suspend"',
        standard: "posix"
    },
    {
        name: "SIGTTIN",
        number: 21,
        action: "pause",
        description: "Background process cannot read terminal input",
        standard: "posix"
    },
    {
        name: "SIGBREAK",
        number: 21,
        action: "terminate",
        description: "User interruption with CTRL-BREAK",
        standard: "other"
    },
    {
        name: "SIGTTOU",
        number: 22,
        action: "pause",
        description: "Background process cannot write to terminal output",
        standard: "posix"
    },
    {
        name: "SIGURG",
        number: 23,
        action: "ignore",
        description: "Socket received out-of-band data",
        standard: "bsd"
    },
    {
        name: "SIGXCPU",
        number: 24,
        action: "core",
        description: "Process timed out",
        standard: "bsd"
    },
    {
        name: "SIGXFSZ",
        number: 25,
        action: "core",
        description: "File too big",
        standard: "bsd"
    },
    {
        name: "SIGVTALRM",
        number: 26,
        action: "terminate",
        description: "Timeout or timer",
        standard: "bsd"
    },
    {
        name: "SIGPROF",
        number: 27,
        action: "terminate",
        description: "Timeout or timer",
        standard: "bsd"
    },
    {
        name: "SIGWINCH",
        number: 28,
        action: "ignore",
        description: "Terminal window size changed",
        standard: "bsd"
    },
    {
        name: "SIGIO",
        number: 29,
        action: "terminate",
        description: "I/O is available",
        standard: "other"
    },
    {
        name: "SIGPOLL",
        number: 29,
        action: "terminate",
        description: "Watched event",
        standard: "other"
    },
    {
        name: "SIGINFO",
        number: 29,
        action: "ignore",
        description: "Request for process information",
        standard: "other"
    },
    {
        name: "SIGPWR",
        number: 30,
        action: "terminate",
        description: "Device running out of power",
        standard: "systemv"
    },
    {
        name: "SIGSYS",
        number: 31,
        action: "core",
        description: "Invalid system call",
        standard: "other"
    },
    {
        name: "SIGUNUSED",
        number: 31,
        action: "terminate",
        description: "Invalid system call",
        standard: "other"
    }
];



const $07e9a8b7cfb3428a$export$c50078d4faa171f0 = ()=>{
    const realtimeSignals = (0, $80e7969f4cf1b9d6$export$e221a98f4fd84d36)();
    const signals = [
        ...(0, $58ec265091710a29$export$a43bf6822cc694af),
        ...realtimeSignals
    ].map($07e9a8b7cfb3428a$var$normalizeSignal);
    return signals;
};
const $07e9a8b7cfb3428a$var$normalizeSignal = ({ name: name, number: defaultNumber, description: description, action: action, forced: forced = false, standard: standard })=>{
    const { signals: { [name]: constantSignal } } = (0, $iIEVR$constants);
    const supported = constantSignal !== undefined;
    const number = supported ? constantSignal : defaultNumber;
    return {
        name: name,
        number: number,
        description: description,
        supported: supported,
        action: action,
        forced: forced,
        standard: standard
    };
};


const $166426e5b830937c$var$getSignalsByName = ()=>{
    const signals = (0, $07e9a8b7cfb3428a$export$c50078d4faa171f0)();
    return Object.fromEntries(signals.map($166426e5b830937c$var$getSignalByName));
};
const $166426e5b830937c$var$getSignalByName = ({ name: name, number: number, description: description, supported: supported, action: action, forced: forced, standard: standard })=>[
        name,
        {
            name: name,
            number: number,
            description: description,
            supported: supported,
            action: action,
            forced: forced,
            standard: standard
        }
    ];
const $166426e5b830937c$export$c3fcb39d6848c78d = $166426e5b830937c$var$getSignalsByName();
const $166426e5b830937c$var$getSignalsByNumber = ()=>{
    const signals = (0, $07e9a8b7cfb3428a$export$c50078d4faa171f0)();
    const length = (0, $80e7969f4cf1b9d6$export$dc8812f2f8882ff4) + 1;
    const signalsA = Array.from({
        length: length
    }, (value, number)=>$166426e5b830937c$var$getSignalByNumber(number, signals));
    return Object.assign({}, ...signalsA);
};
const $166426e5b830937c$var$getSignalByNumber = (number, signals)=>{
    const signal = $166426e5b830937c$var$findSignalByNumber(number, signals);
    if (signal === undefined) return {};
    const { name: name, description: description, supported: supported, action: action, forced: forced, standard: standard } = signal;
    return {
        [number]: {
            name: name,
            number: number,
            description: description,
            supported: supported,
            action: action,
            forced: forced,
            standard: standard
        }
    };
};
const $166426e5b830937c$var$findSignalByNumber = (number, signals)=>{
    const signal = signals.find(({ name: name })=>(0, $iIEVR$constants).signals[name] === number);
    if (signal !== undefined) return signal;
    return signals.find((signalA)=>signalA.number === number);
};
const $166426e5b830937c$export$12f57f97a08d2468 = $166426e5b830937c$var$getSignalsByNumber();


const $e3e9af5a865661d4$var$getErrorPrefix = ({ timedOut: timedOut, timeout: timeout, errorCode: errorCode, signal: signal, signalDescription: signalDescription, exitCode: exitCode, isCanceled: isCanceled })=>{
    if (timedOut) return `timed out after ${timeout} milliseconds`;
    if (isCanceled) return "was canceled";
    if (errorCode !== undefined) return `failed with ${errorCode}`;
    if (signal !== undefined) return `was killed with ${signal} (${signalDescription})`;
    if (exitCode !== undefined) return `failed with exit code ${exitCode}`;
    return "failed";
};
const $e3e9af5a865661d4$export$5a4bb2b1c89bdce7 = ({ stdout: stdout, stderr: stderr, all: all, error: error, signal: signal, exitCode: exitCode, command: command, escapedCommand: escapedCommand, timedOut: timedOut, isCanceled: isCanceled, killed: killed, parsed: { options: { timeout: timeout, cwd: cwd = (0, $iIEVR$nodeprocess).cwd() } } })=>{
    // `signal` and `exitCode` emitted on `spawned.on('exit')` event can be `null`.
    // We normalize them to `undefined`
    exitCode = exitCode === null ? undefined : exitCode;
    signal = signal === null ? undefined : signal;
    const signalDescription = signal === undefined ? undefined : (0, $166426e5b830937c$export$c3fcb39d6848c78d)[signal].description;
    const errorCode = error && error.code;
    const prefix = $e3e9af5a865661d4$var$getErrorPrefix({
        timedOut: timedOut,
        timeout: timeout,
        errorCode: errorCode,
        signal: signal,
        signalDescription: signalDescription,
        exitCode: exitCode,
        isCanceled: isCanceled
    });
    const execaMessage = `Command ${prefix}: ${command}`;
    const isError = Object.prototype.toString.call(error) === "[object Error]";
    const shortMessage = isError ? `${execaMessage}\n${error.message}` : execaMessage;
    const message = [
        shortMessage,
        stderr,
        stdout
    ].filter(Boolean).join("\n");
    if (isError) {
        error.originalMessage = error.message;
        error.message = message;
    } else error = new Error(message);
    error.shortMessage = shortMessage;
    error.command = command;
    error.escapedCommand = escapedCommand;
    error.exitCode = exitCode;
    error.signal = signal;
    error.signalDescription = signalDescription;
    error.stdout = stdout;
    error.stderr = stderr;
    error.cwd = cwd;
    if (all !== undefined) error.all = all;
    if ("bufferedData" in error) delete error.bufferedData;
    error.failed = true;
    error.timedOut = Boolean(timedOut);
    error.isCanceled = isCanceled;
    error.killed = killed && !timedOut;
    return error;
};


const $393723fe1aa3d025$var$aliases = [
    "stdin",
    "stdout",
    "stderr"
];
const $393723fe1aa3d025$var$hasAlias = (options)=>$393723fe1aa3d025$var$aliases.some((alias)=>options[alias] !== undefined);
const $393723fe1aa3d025$export$a581401a57fac02e = (options)=>{
    if (!options) return;
    const { stdio: stdio } = options;
    if (stdio === undefined) return $393723fe1aa3d025$var$aliases.map((alias)=>options[alias]);
    if ($393723fe1aa3d025$var$hasAlias(options)) throw new Error(`It's not possible to provide \`stdio\` in combination with one of ${$393723fe1aa3d025$var$aliases.map((alias)=>`\`${alias}\``).join(", ")}`);
    if (typeof stdio === "string") return stdio;
    if (!Array.isArray(stdio)) throw new TypeError(`Expected \`stdio\` to be of type \`string\` or \`Array\`, got \`${typeof stdio}\``);
    const length = Math.max(stdio.length, $393723fe1aa3d025$var$aliases.length);
    return Array.from({
        length: length
    }, (value, index)=>stdio[index]);
};
const $393723fe1aa3d025$export$889423b478ae2ba = (options)=>{
    const stdio = $393723fe1aa3d025$export$a581401a57fac02e(options);
    if (stdio === "ipc") return "ipc";
    if (stdio === undefined || typeof stdio === "string") return [
        stdio,
        stdio,
        stdio,
        "ipc"
    ];
    if (stdio.includes("ipc")) return stdio;
    return [
        ...stdio,
        "ipc"
    ];
};



var $fc85ce36a887176b$exports = {};
// Note: since nyc uses this module to output coverage, any lines
// that are in the direct sync flow of nyc's outputCoverage are
// ignored, since we can never get coverage for them.
// grab a reference to node's real process object right away
var $fc85ce36a887176b$var$process = $parcel$global.process;
const $fc85ce36a887176b$var$processOk = function(process) {
    return process && typeof process === "object" && typeof process.removeListener === "function" && typeof process.emit === "function" && typeof process.reallyExit === "function" && typeof process.listeners === "function" && typeof process.kill === "function" && typeof process.pid === "number" && typeof process.on === "function";
};



// some kind of non-node environment, just no-op
/* istanbul ignore if */ if (!$fc85ce36a887176b$var$processOk($fc85ce36a887176b$var$process)) $fc85ce36a887176b$exports = function() {
    return function() {};
};
else {
    var $fc85ce36a887176b$var$assert = $iIEVR$assert;
    var $fc85ce36a887176b$var$signals = (parcelRequire("6j8hI"));
    var $fc85ce36a887176b$var$isWin = /^win/i.test($fc85ce36a887176b$var$process.platform);
    var $fc85ce36a887176b$var$EE = $iIEVR$events;
    /* istanbul ignore if */ if (typeof $fc85ce36a887176b$var$EE !== "function") $fc85ce36a887176b$var$EE = $fc85ce36a887176b$var$EE.EventEmitter;
    var $fc85ce36a887176b$var$emitter;
    if ($fc85ce36a887176b$var$process.__signal_exit_emitter__) $fc85ce36a887176b$var$emitter = $fc85ce36a887176b$var$process.__signal_exit_emitter__;
    else {
        $fc85ce36a887176b$var$emitter = $fc85ce36a887176b$var$process.__signal_exit_emitter__ = new $fc85ce36a887176b$var$EE();
        $fc85ce36a887176b$var$emitter.count = 0;
        $fc85ce36a887176b$var$emitter.emitted = {};
    }
    // Because this emitter is a global, we have to check to see if a
    // previous version of this library failed to enable infinite listeners.
    // I know what you're about to say.  But literally everything about
    // signal-exit is a compromise with evil.  Get used to it.
    if (!$fc85ce36a887176b$var$emitter.infinite) {
        $fc85ce36a887176b$var$emitter.setMaxListeners(Infinity);
        $fc85ce36a887176b$var$emitter.infinite = true;
    }
    $fc85ce36a887176b$exports = function(cb, opts) {
        /* istanbul ignore if */ if (!$fc85ce36a887176b$var$processOk($parcel$global.process)) return function() {};
        $fc85ce36a887176b$var$assert.equal(typeof cb, "function", "a callback must be provided for exit handler");
        if ($fc85ce36a887176b$var$loaded === false) $fc85ce36a887176b$var$load();
        var ev = "exit";
        if (opts && opts.alwaysLast) ev = "afterexit";
        var remove = function() {
            $fc85ce36a887176b$var$emitter.removeListener(ev, cb);
            if ($fc85ce36a887176b$var$emitter.listeners("exit").length === 0 && $fc85ce36a887176b$var$emitter.listeners("afterexit").length === 0) $fc85ce36a887176b$var$unload();
        };
        $fc85ce36a887176b$var$emitter.on(ev, cb);
        return remove;
    };
    var $fc85ce36a887176b$var$unload = function unload() {
        if (!$fc85ce36a887176b$var$loaded || !$fc85ce36a887176b$var$processOk($parcel$global.process)) return;
        $fc85ce36a887176b$var$loaded = false;
        $fc85ce36a887176b$var$signals.forEach(function(sig) {
            try {
                $fc85ce36a887176b$var$process.removeListener(sig, $fc85ce36a887176b$var$sigListeners[sig]);
            } catch (er) {}
        });
        $fc85ce36a887176b$var$process.emit = $fc85ce36a887176b$var$originalProcessEmit;
        $fc85ce36a887176b$var$process.reallyExit = $fc85ce36a887176b$var$originalProcessReallyExit;
        $fc85ce36a887176b$var$emitter.count -= 1;
    };
    $fc85ce36a887176b$exports.unload = $fc85ce36a887176b$var$unload;
    var $fc85ce36a887176b$var$emit = function emit(event, code, signal) {
        /* istanbul ignore if */ if ($fc85ce36a887176b$var$emitter.emitted[event]) return;
        $fc85ce36a887176b$var$emitter.emitted[event] = true;
        $fc85ce36a887176b$var$emitter.emit(event, code, signal);
    };
    // { <signal>: <listener fn>, ... }
    var $fc85ce36a887176b$var$sigListeners = {};
    $fc85ce36a887176b$var$signals.forEach(function(sig) {
        $fc85ce36a887176b$var$sigListeners[sig] = function listener() {
            /* istanbul ignore if */ if (!$fc85ce36a887176b$var$processOk($parcel$global.process)) return;
            // If there are no other listeners, an exit is coming!
            // Simplest way: remove us and then re-send the signal.
            // We know that this will kill the process, so we can
            // safely emit now.
            var listeners = $fc85ce36a887176b$var$process.listeners(sig);
            if (listeners.length === $fc85ce36a887176b$var$emitter.count) {
                $fc85ce36a887176b$var$unload();
                $fc85ce36a887176b$var$emit("exit", null, sig);
                /* istanbul ignore next */ $fc85ce36a887176b$var$emit("afterexit", null, sig);
                /* istanbul ignore next */ if ($fc85ce36a887176b$var$isWin && sig === "SIGHUP") // "SIGHUP" throws an `ENOSYS` error on Windows,
                // so use a supported signal instead
                sig = "SIGINT";
                /* istanbul ignore next */ $fc85ce36a887176b$var$process.kill($fc85ce36a887176b$var$process.pid, sig);
            }
        };
    });
    $fc85ce36a887176b$exports.signals = function() {
        return $fc85ce36a887176b$var$signals;
    };
    var $fc85ce36a887176b$var$loaded = false;
    var $fc85ce36a887176b$var$load = function load() {
        if ($fc85ce36a887176b$var$loaded || !$fc85ce36a887176b$var$processOk($parcel$global.process)) return;
        $fc85ce36a887176b$var$loaded = true;
        // This is the number of onSignalExit's that are in play.
        // It's important so that we can count the correct number of
        // listeners on signals, and don't wait for the other one to
        // handle it instead of us.
        $fc85ce36a887176b$var$emitter.count += 1;
        $fc85ce36a887176b$var$signals = $fc85ce36a887176b$var$signals.filter(function(sig) {
            try {
                $fc85ce36a887176b$var$process.on(sig, $fc85ce36a887176b$var$sigListeners[sig]);
                return true;
            } catch (er) {
                return false;
            }
        });
        $fc85ce36a887176b$var$process.emit = $fc85ce36a887176b$var$processEmit;
        $fc85ce36a887176b$var$process.reallyExit = $fc85ce36a887176b$var$processReallyExit;
    };
    $fc85ce36a887176b$exports.load = $fc85ce36a887176b$var$load;
    var $fc85ce36a887176b$var$originalProcessReallyExit = $fc85ce36a887176b$var$process.reallyExit;
    var $fc85ce36a887176b$var$processReallyExit = function processReallyExit(code) {
        /* istanbul ignore if */ if (!$fc85ce36a887176b$var$processOk($parcel$global.process)) return;
        $fc85ce36a887176b$var$process.exitCode = code || /* istanbul ignore next */ 0;
        $fc85ce36a887176b$var$emit("exit", $fc85ce36a887176b$var$process.exitCode, null);
        /* istanbul ignore next */ $fc85ce36a887176b$var$emit("afterexit", $fc85ce36a887176b$var$process.exitCode, null);
        /* istanbul ignore next */ $fc85ce36a887176b$var$originalProcessReallyExit.call($fc85ce36a887176b$var$process, $fc85ce36a887176b$var$process.exitCode);
    };
    var $fc85ce36a887176b$var$originalProcessEmit = $fc85ce36a887176b$var$process.emit;
    var $fc85ce36a887176b$var$processEmit = function processEmit(ev, arg) {
        if (ev === "exit" && $fc85ce36a887176b$var$processOk($parcel$global.process)) {
            /* istanbul ignore else */ if (arg !== undefined) $fc85ce36a887176b$var$process.exitCode = arg;
            var ret = $fc85ce36a887176b$var$originalProcessEmit.apply(this, arguments);
            /* istanbul ignore next */ $fc85ce36a887176b$var$emit("exit", $fc85ce36a887176b$var$process.exitCode, null);
            /* istanbul ignore next */ $fc85ce36a887176b$var$emit("afterexit", $fc85ce36a887176b$var$process.exitCode, null);
            /* istanbul ignore next */ return ret;
        } else return $fc85ce36a887176b$var$originalProcessEmit.apply(this, arguments);
    };
}


const $2eb4528b96a0cef9$var$DEFAULT_FORCE_KILL_TIMEOUT = 5000;
const $2eb4528b96a0cef9$export$971fa1b57c7f00b = (kill, signal = "SIGTERM", options = {})=>{
    const killResult = kill(signal);
    $2eb4528b96a0cef9$var$setKillTimeout(kill, signal, options, killResult);
    return killResult;
};
const $2eb4528b96a0cef9$var$setKillTimeout = (kill, signal, options, killResult)=>{
    if (!$2eb4528b96a0cef9$var$shouldForceKill(signal, options, killResult)) return;
    const timeout = $2eb4528b96a0cef9$var$getForceKillAfterTimeout(options);
    const t = setTimeout(()=>{
        kill("SIGKILL");
    }, timeout);
    // Guarded because there's no `.unref()` when `execa` is used in the renderer
    // process in Electron. This cannot be tested since we don't run tests in
    // Electron.
    // istanbul ignore else
    if (t.unref) t.unref();
};
const $2eb4528b96a0cef9$var$shouldForceKill = (signal, { forceKillAfterTimeout: forceKillAfterTimeout }, killResult)=>$2eb4528b96a0cef9$var$isSigterm(signal) && forceKillAfterTimeout !== false && killResult;
const $2eb4528b96a0cef9$var$isSigterm = (signal)=>signal === (0, $iIEVR$nodeos).constants.signals.SIGTERM || typeof signal === "string" && signal.toUpperCase() === "SIGTERM";
const $2eb4528b96a0cef9$var$getForceKillAfterTimeout = ({ forceKillAfterTimeout: forceKillAfterTimeout = true })=>{
    if (forceKillAfterTimeout === true) return $2eb4528b96a0cef9$var$DEFAULT_FORCE_KILL_TIMEOUT;
    if (!Number.isFinite(forceKillAfterTimeout) || forceKillAfterTimeout < 0) throw new TypeError(`Expected the \`forceKillAfterTimeout\` option to be a non-negative integer, got \`${forceKillAfterTimeout}\` (${typeof forceKillAfterTimeout})`);
    return forceKillAfterTimeout;
};
const $2eb4528b96a0cef9$export$667e13cd9b70ca17 = (spawned, context)=>{
    const killResult = spawned.kill();
    if (killResult) context.isCanceled = true;
};
const $2eb4528b96a0cef9$var$timeoutKill = (spawned, signal, reject)=>{
    spawned.kill(signal);
    reject(Object.assign(new Error("Timed out"), {
        timedOut: true,
        signal: signal
    }));
};
const $2eb4528b96a0cef9$export$6bcc98999eb82896 = (spawned, { timeout: timeout, killSignal: killSignal = "SIGTERM" }, spawnedPromise)=>{
    if (timeout === 0 || timeout === undefined) return spawnedPromise;
    let timeoutId;
    const timeoutPromise = new Promise((resolve, reject)=>{
        timeoutId = setTimeout(()=>{
            $2eb4528b96a0cef9$var$timeoutKill(spawned, killSignal, reject);
        }, timeout);
    });
    const safeSpawnedPromise = spawnedPromise.finally(()=>{
        clearTimeout(timeoutId);
    });
    return Promise.race([
        timeoutPromise,
        safeSpawnedPromise
    ]);
};
const $2eb4528b96a0cef9$export$3186f8866f616f9f = ({ timeout: timeout })=>{
    if (timeout !== undefined && (!Number.isFinite(timeout) || timeout < 0)) throw new TypeError(`Expected the \`timeout\` option to be a non-negative integer, got \`${timeout}\` (${typeof timeout})`);
};
const $2eb4528b96a0cef9$export$79fc3056c9ca4ada = async (spawned, { cleanup: cleanup, detached: detached }, timedPromise)=>{
    if (!cleanup || detached) return timedPromise;
    const removeExitHandler = (0, (/*@__PURE__*/$parcel$interopDefault($fc85ce36a887176b$exports)))(()=>{
        spawned.kill();
    });
    return timedPromise.finally(()=>{
        removeExitHandler();
    });
};




function $e859056a201556d0$export$294a92d8f7b3979(stream) {
    return stream !== null && typeof stream === "object" && typeof stream.pipe === "function";
}
function $e859056a201556d0$export$b58a61c52edb4f66(stream) {
    return $e859056a201556d0$export$294a92d8f7b3979(stream) && stream.writable !== false && typeof stream._write === "function" && typeof stream._writableState === "object";
}
function $e859056a201556d0$export$ac613ff475b69d05(stream) {
    return $e859056a201556d0$export$294a92d8f7b3979(stream) && stream.readable !== false && typeof stream._read === "function" && typeof stream._readableState === "object";
}
function $e859056a201556d0$export$f92d8ccfaec172d4(stream) {
    return $e859056a201556d0$export$b58a61c52edb4f66(stream) && $e859056a201556d0$export$ac613ff475b69d05(stream);
}
function $e859056a201556d0$export$3053cdc6f2e088fd(stream) {
    return $e859056a201556d0$export$f92d8ccfaec172d4(stream) && typeof stream._transform === "function";
}


const $dc8d3fb88008b965$var$isExecaChildProcess = (target)=>target instanceof (0, $iIEVR$ChildProcess) && typeof target.then === "function";
const $dc8d3fb88008b965$var$pipeToTarget = (spawned, streamName, target)=>{
    if (typeof target === "string") {
        spawned[streamName].pipe((0, $iIEVR$createWriteStream)(target));
        return spawned;
    }
    if ((0, $e859056a201556d0$export$b58a61c52edb4f66)(target)) {
        spawned[streamName].pipe(target);
        return spawned;
    }
    if (!$dc8d3fb88008b965$var$isExecaChildProcess(target)) throw new TypeError("The second argument must be a string, a stream or an Execa child process.");
    if (!(0, $e859056a201556d0$export$b58a61c52edb4f66)(target.stdin)) throw new TypeError("The target child process's stdin must be available.");
    spawned[streamName].pipe(target.stdin);
    return target;
};
const $dc8d3fb88008b965$export$14becf8d91886424 = (spawned)=>{
    if (spawned.stdout !== null) spawned.pipeStdout = $dc8d3fb88008b965$var$pipeToTarget.bind(undefined, spawned, "stdout");
    if (spawned.stderr !== null) spawned.pipeStderr = $dc8d3fb88008b965$var$pipeToTarget.bind(undefined, spawned, "stderr");
    if (spawned.all !== undefined) spawned.pipeAll = $dc8d3fb88008b965$var$pipeToTarget.bind(undefined, spawned, "all");
};




var $b83901278b371d93$exports = {};
"use strict";

var $b83901278b371d93$require$BufferConstants = $iIEVR$constants1;


var $b83901278b371d93$require$promisify = $iIEVR$promisify;
var $27948bfb78a47362$exports = {};
"use strict";

var $27948bfb78a47362$require$PassThroughStream = $iIEVR$PassThrough;
$27948bfb78a47362$exports = (options)=>{
    options = {
        ...options
    };
    const { array: array } = options;
    let { encoding: encoding } = options;
    const isBuffer = encoding === "buffer";
    let objectMode = false;
    if (array) objectMode = !(encoding || isBuffer);
    else encoding = encoding || "utf8";
    if (isBuffer) encoding = null;
    const stream = new $27948bfb78a47362$require$PassThroughStream({
        objectMode: objectMode
    });
    if (encoding) stream.setEncoding(encoding);
    let length = 0;
    const chunks = [];
    stream.on("data", (chunk)=>{
        chunks.push(chunk);
        if (objectMode) length = chunks.length;
        else length += chunk.length;
    });
    stream.getBufferedValue = ()=>{
        if (array) return chunks;
        return isBuffer ? Buffer.concat(chunks, length) : chunks.join("");
    };
    stream.getBufferedLength = ()=>length;
    return stream;
};


const $b83901278b371d93$var$streamPipelinePromisified = $b83901278b371d93$require$promisify($iIEVR$pipeline);
class $b83901278b371d93$var$MaxBufferError extends Error {
    constructor(){
        super("maxBuffer exceeded");
        this.name = "MaxBufferError";
    }
}
async function $b83901278b371d93$var$getStream(inputStream, options) {
    if (!inputStream) throw new Error("Expected a stream");
    options = {
        maxBuffer: Infinity,
        ...options
    };
    const { maxBuffer: maxBuffer } = options;
    const stream = $27948bfb78a47362$exports(options);
    await new Promise((resolve, reject)=>{
        const rejectPromise = (error)=>{
            // Don't retrieve an oversized buffer.
            if (error && stream.getBufferedLength() <= $b83901278b371d93$require$BufferConstants.MAX_LENGTH) error.bufferedData = stream.getBufferedValue();
            reject(error);
        };
        (async ()=>{
            try {
                await $b83901278b371d93$var$streamPipelinePromisified(inputStream, stream);
                resolve();
            } catch (error) {
                rejectPromise(error);
            }
        })();
        stream.on("data", ()=>{
            if (stream.getBufferedLength() > maxBuffer) rejectPromise(new $b83901278b371d93$var$MaxBufferError());
        });
    });
    return stream.getBufferedValue();
}
$b83901278b371d93$exports = $b83901278b371d93$var$getStream;
$b83901278b371d93$exports.buffer = (stream, options)=>$b83901278b371d93$var$getStream(stream, {
        ...options,
        encoding: "buffer"
    });
$b83901278b371d93$exports.array = (stream, options)=>$b83901278b371d93$var$getStream(stream, {
        ...options,
        array: true
    });
$b83901278b371d93$exports.MaxBufferError = $b83901278b371d93$var$MaxBufferError;


var $fb04cce24c70cb6a$exports = {};
"use strict";

var $fb04cce24c70cb6a$require$PassThrough = $iIEVR$PassThrough;
$fb04cce24c70cb6a$exports = function() {
    var sources = [];
    var output = new $fb04cce24c70cb6a$require$PassThrough({
        objectMode: true
    });
    output.setMaxListeners(0);
    output.add = add;
    output.isEmpty = isEmpty;
    output.on("unpipe", remove);
    Array.prototype.slice.call(arguments).forEach(add);
    return output;
    function add(source) {
        if (Array.isArray(source)) {
            source.forEach(add);
            return this;
        }
        sources.push(source);
        source.once("end", remove.bind(null, source));
        source.once("error", output.emit.bind(output, "error"));
        source.pipe(output, {
            end: false
        });
        return this;
    }
    function isEmpty() {
        return sources.length == 0;
    }
    function remove(source) {
        sources = sources.filter(function(it) {
            return it !== source;
        });
        if (!sources.length && output.readable) output.end();
    }
};


const $74dcc2ed737283e7$var$validateInputOptions = (input)=>{
    if (input !== undefined) throw new TypeError("The `input` and `inputFile` options cannot be both set.");
};
const $74dcc2ed737283e7$var$getInputSync = ({ input: input, inputFile: inputFile })=>{
    if (typeof inputFile !== "string") return input;
    $74dcc2ed737283e7$var$validateInputOptions(input);
    return (0, $iIEVR$readFileSync)(inputFile);
};
const $74dcc2ed737283e7$export$7f2f9b6457412b41 = (options)=>{
    const input = $74dcc2ed737283e7$var$getInputSync(options);
    if ((0, $e859056a201556d0$export$294a92d8f7b3979)(input)) throw new TypeError("The `input` option cannot be a stream in sync mode");
    return input;
};
const $74dcc2ed737283e7$var$getInput = ({ input: input, inputFile: inputFile })=>{
    if (typeof inputFile !== "string") return input;
    $74dcc2ed737283e7$var$validateInputOptions(input);
    return (0, $iIEVR$createReadStream)(inputFile);
};
const $74dcc2ed737283e7$export$412508d679148d5c = (spawned, options)=>{
    const input = $74dcc2ed737283e7$var$getInput(options);
    if (input === undefined) return;
    if ((0, $e859056a201556d0$export$294a92d8f7b3979)(input)) input.pipe(spawned.stdin);
    else spawned.stdin.end(input);
};
const $74dcc2ed737283e7$export$41f5c0c12dadd6ae = (spawned, { all: all })=>{
    if (!all || !spawned.stdout && !spawned.stderr) return;
    const mixed = (0, (/*@__PURE__*/$parcel$interopDefault($fb04cce24c70cb6a$exports)))();
    if (spawned.stdout) mixed.add(spawned.stdout);
    if (spawned.stderr) mixed.add(spawned.stderr);
    return mixed;
};
// On failure, `result.stdout|stderr|all` should contain the currently buffered stream
const $74dcc2ed737283e7$var$getBufferedData = async (stream, streamPromise)=>{
    // When `buffer` is `false`, `streamPromise` is `undefined` and there is no buffered data to retrieve
    if (!stream || streamPromise === undefined) return;
    stream.destroy();
    try {
        return await streamPromise;
    } catch (error) {
        return error.bufferedData;
    }
};
const $74dcc2ed737283e7$var$getStreamPromise = (stream, { encoding: encoding, buffer: buffer, maxBuffer: maxBuffer })=>{
    if (!stream || !buffer) return;
    if (encoding) return (0, (/*@__PURE__*/$parcel$interopDefault($b83901278b371d93$exports)))(stream, {
        encoding: encoding,
        maxBuffer: maxBuffer
    });
    return (0, (/*@__PURE__*/$parcel$interopDefault($b83901278b371d93$exports))).buffer(stream, {
        maxBuffer: maxBuffer
    });
};
const $74dcc2ed737283e7$export$67b768ac9e1c70fa = async ({ stdout: stdout, stderr: stderr, all: all }, { encoding: encoding, buffer: buffer, maxBuffer: maxBuffer }, processDone)=>{
    const stdoutPromise = $74dcc2ed737283e7$var$getStreamPromise(stdout, {
        encoding: encoding,
        buffer: buffer,
        maxBuffer: maxBuffer
    });
    const stderrPromise = $74dcc2ed737283e7$var$getStreamPromise(stderr, {
        encoding: encoding,
        buffer: buffer,
        maxBuffer: maxBuffer
    });
    const allPromise = $74dcc2ed737283e7$var$getStreamPromise(all, {
        encoding: encoding,
        buffer: buffer,
        maxBuffer: maxBuffer * 2
    });
    try {
        return await Promise.all([
            processDone,
            stdoutPromise,
            stderrPromise,
            allPromise
        ]);
    } catch (error) {
        return Promise.all([
            {
                error: error,
                signal: error.signal,
                timedOut: error.timedOut
            },
            $74dcc2ed737283e7$var$getBufferedData(stdout, stdoutPromise),
            $74dcc2ed737283e7$var$getBufferedData(stderr, stderrPromise),
            $74dcc2ed737283e7$var$getBufferedData(all, allPromise)
        ]);
    }
};


// eslint-disable-next-line unicorn/prefer-top-level-await
const $8bc863ccfadd07ed$var$nativePromisePrototype = (async ()=>{})().constructor.prototype;
const $8bc863ccfadd07ed$var$descriptors = [
    "then",
    "catch",
    "finally"
].map((property)=>[
        property,
        Reflect.getOwnPropertyDescriptor($8bc863ccfadd07ed$var$nativePromisePrototype, property)
    ]);
const $8bc863ccfadd07ed$export$e6eb0007fd542aba = (spawned, promise)=>{
    for (const [property, descriptor] of $8bc863ccfadd07ed$var$descriptors){
        // Starting the main `promise` is deferred to avoid consuming streams
        const value = typeof promise === "function" ? (...args)=>Reflect.apply(descriptor.value, promise(), args) : descriptor.value.bind(promise);
        Reflect.defineProperty(spawned, property, {
            ...descriptor,
            value: value
        });
    }
};
const $8bc863ccfadd07ed$export$6e3a9b5342d42997 = (spawned)=>new Promise((resolve, reject)=>{
        spawned.on("exit", (exitCode, signal)=>{
            resolve({
                exitCode: exitCode,
                signal: signal
            });
        });
        spawned.on("error", (error)=>{
            reject(error);
        });
        if (spawned.stdin) spawned.stdin.on("error", (error)=>{
            reject(error);
        });
    });




const $12926dfec523da61$var$normalizeArgs = (file, args = [])=>{
    if (!Array.isArray(args)) return [
        file
    ];
    return [
        file,
        ...args
    ];
};
const $12926dfec523da61$var$NO_ESCAPE_REGEXP = /^[\w.-]+$/;
const $12926dfec523da61$var$DOUBLE_QUOTES_REGEXP = /"/g;
const $12926dfec523da61$var$escapeArg = (arg)=>{
    if (typeof arg !== "string" || $12926dfec523da61$var$NO_ESCAPE_REGEXP.test(arg)) return arg;
    return `"${arg.replace($12926dfec523da61$var$DOUBLE_QUOTES_REGEXP, '\\"')}"`;
};
const $12926dfec523da61$export$ab3db8fe5ebf3a1 = (file, args)=>$12926dfec523da61$var$normalizeArgs(file, args).join(" ");
const $12926dfec523da61$export$9d3099014bd914f8 = (file, args)=>$12926dfec523da61$var$normalizeArgs(file, args).map((arg)=>$12926dfec523da61$var$escapeArg(arg)).join(" ");
const $12926dfec523da61$var$SPACES_REGEXP = / +/g;
const $12926dfec523da61$export$78bcee23e0849f6a = (command)=>{
    const tokens = [];
    for (const token of command.trim().split($12926dfec523da61$var$SPACES_REGEXP)){
        // Allow spaces to be escaped by a backslash if not meant as a delimiter
        const previousToken = tokens[tokens.length - 1];
        if (previousToken && previousToken.endsWith("\\")) // Merge previous token with current one
        tokens[tokens.length - 1] = `${previousToken.slice(0, -1)} ${token}`;
        else tokens.push(token);
    }
    return tokens;
};
const $12926dfec523da61$var$parseExpression = (expression)=>{
    const typeOfExpression = typeof expression;
    if (typeOfExpression === "string") return expression;
    if (typeOfExpression === "number") return String(expression);
    if (typeOfExpression === "object" && expression !== null && !(expression instanceof (0, $iIEVR$ChildProcess)) && "stdout" in expression) {
        const typeOfStdout = typeof expression.stdout;
        if (typeOfStdout === "string") return expression.stdout;
        if ((0, $iIEVR$Buffer).isBuffer(expression.stdout)) return expression.stdout.toString();
        throw new TypeError(`Unexpected "${typeOfStdout}" stdout in template expression`);
    }
    throw new TypeError(`Unexpected "${typeOfExpression}" in template expression`);
};
const $12926dfec523da61$var$concatTokens = (tokens, nextTokens, isNew)=>isNew || tokens.length === 0 || nextTokens.length === 0 ? [
        ...tokens,
        ...nextTokens
    ] : [
        ...tokens.slice(0, -1),
        `${tokens[tokens.length - 1]}${nextTokens[0]}`,
        ...nextTokens.slice(1)
    ];
const $12926dfec523da61$var$parseTemplate = ({ templates: templates, expressions: expressions, tokens: tokens, index: index, template: template })=>{
    const templateString = template ?? templates.raw[index];
    const templateTokens = templateString.split($12926dfec523da61$var$SPACES_REGEXP).filter(Boolean);
    const newTokens = $12926dfec523da61$var$concatTokens(tokens, templateTokens, templateString.startsWith(" "));
    if (index === expressions.length) return newTokens;
    const expression = expressions[index];
    const expressionTokens = Array.isArray(expression) ? expression.map((expression)=>$12926dfec523da61$var$parseExpression(expression)) : [
        $12926dfec523da61$var$parseExpression(expression)
    ];
    return $12926dfec523da61$var$concatTokens(newTokens, expressionTokens, templateString.endsWith(" "));
};
const $12926dfec523da61$export$4a6ee54de9b0f25d = (templates, expressions)=>{
    let tokens = [];
    for (const [index, template] of templates.entries())tokens = $12926dfec523da61$var$parseTemplate({
        templates: templates,
        expressions: expressions,
        tokens: tokens,
        index: index,
        template: template
    });
    return tokens;
};




const $f489e9cc4200146e$export$38bb3c1fbaa0bdcf = (0, $iIEVR$debuglog)("execa").enabled;
const $f489e9cc4200146e$var$padField = (field, padding)=>String(field).padStart(padding, "0");
const $f489e9cc4200146e$var$getTimestamp = ()=>{
    const date = new Date();
    return `${$f489e9cc4200146e$var$padField(date.getHours(), 2)}:${$f489e9cc4200146e$var$padField(date.getMinutes(), 2)}:${$f489e9cc4200146e$var$padField(date.getSeconds(), 2)}.${$f489e9cc4200146e$var$padField(date.getMilliseconds(), 3)}`;
};
const $f489e9cc4200146e$export$3bb886c4c1352118 = (escapedCommand, { verbose: verbose })=>{
    if (!verbose) return;
    (0, $iIEVR$nodeprocess).stderr.write(`[${$f489e9cc4200146e$var$getTimestamp()}] ${escapedCommand}\n`);
};


const $5592df8b3ad65217$var$DEFAULT_MAX_BUFFER = 100000000;
const $5592df8b3ad65217$var$getEnv = ({ env: envOption, extendEnv: extendEnv, preferLocal: preferLocal, localDir: localDir, execPath: execPath })=>{
    const env = extendEnv ? {
        ...(0, $iIEVR$nodeprocess).env,
        ...envOption
    } : envOption;
    if (preferLocal) return (0, $68ba7b3258eed759$export$340e1fbaac04248b)({
        env: env,
        cwd: localDir,
        execPath: execPath
    });
    return env;
};
const $5592df8b3ad65217$var$handleArguments = (file, args, options = {})=>{
    const parsed = (0, (/*@__PURE__*/$parcel$interopDefault($daf72ea6e4bc8475$exports)))._parse(file, args, options);
    file = parsed.command;
    args = parsed.args;
    options = parsed.options;
    options = {
        maxBuffer: $5592df8b3ad65217$var$DEFAULT_MAX_BUFFER,
        buffer: true,
        stripFinalNewline: true,
        extendEnv: true,
        preferLocal: false,
        localDir: options.cwd || (0, $iIEVR$nodeprocess).cwd(),
        execPath: (0, $iIEVR$nodeprocess).execPath,
        encoding: "utf8",
        reject: true,
        cleanup: true,
        all: false,
        windowsHide: true,
        verbose: (0, $f489e9cc4200146e$export$38bb3c1fbaa0bdcf),
        ...options
    };
    options.env = $5592df8b3ad65217$var$getEnv(options);
    options.stdio = (0, $393723fe1aa3d025$export$a581401a57fac02e)(options);
    if ((0, $iIEVR$nodeprocess).platform === "win32" && (0, $iIEVR$nodepath).basename(file, ".exe") === "cmd") // #116
    args.unshift("/q");
    return {
        file: file,
        args: args,
        options: options,
        parsed: parsed
    };
};
const $5592df8b3ad65217$var$handleOutput = (options, value, error)=>{
    if (typeof value !== "string" && !(0, $iIEVR$Buffer).isBuffer(value)) // When `execaSync()` errors, we normalize it to '' to mimic `execa()`
    return error === undefined ? undefined : "";
    if (options.stripFinalNewline) return (0, $11f7c326e148db82$export$2e2bcd8739ae039)(value);
    return value;
};
function $5592df8b3ad65217$export$db6b1668e3758717(file, args, options) {
    const parsed = $5592df8b3ad65217$var$handleArguments(file, args, options);
    const command = (0, $12926dfec523da61$export$ab3db8fe5ebf3a1)(file, args);
    const escapedCommand = (0, $12926dfec523da61$export$9d3099014bd914f8)(file, args);
    (0, $f489e9cc4200146e$export$3bb886c4c1352118)(escapedCommand, parsed.options);
    (0, $2eb4528b96a0cef9$export$3186f8866f616f9f)(parsed.options);
    let spawned;
    try {
        spawned = (0, $iIEVR$nodechild_process).spawn(parsed.file, parsed.args, parsed.options);
    } catch (error) {
        // Ensure the returned error is always both a promise and a child process
        const dummySpawned = new (0, $iIEVR$nodechild_process).ChildProcess();
        const errorPromise = Promise.reject((0, $e3e9af5a865661d4$export$5a4bb2b1c89bdce7)({
            error: error,
            stdout: "",
            stderr: "",
            all: "",
            command: command,
            escapedCommand: escapedCommand,
            parsed: parsed,
            timedOut: false,
            isCanceled: false,
            killed: false
        }));
        (0, $8bc863ccfadd07ed$export$e6eb0007fd542aba)(dummySpawned, errorPromise);
        return dummySpawned;
    }
    const spawnedPromise = (0, $8bc863ccfadd07ed$export$6e3a9b5342d42997)(spawned);
    const timedPromise = (0, $2eb4528b96a0cef9$export$6bcc98999eb82896)(spawned, parsed.options, spawnedPromise);
    const processDone = (0, $2eb4528b96a0cef9$export$79fc3056c9ca4ada)(spawned, parsed.options, timedPromise);
    const context = {
        isCanceled: false
    };
    spawned.kill = (0, $2eb4528b96a0cef9$export$971fa1b57c7f00b).bind(null, spawned.kill.bind(spawned));
    spawned.cancel = (0, $2eb4528b96a0cef9$export$667e13cd9b70ca17).bind(null, spawned, context);
    const handlePromise = async ()=>{
        const [{ error: error, exitCode: exitCode, signal: signal, timedOut: timedOut }, stdoutResult, stderrResult, allResult] = await (0, $74dcc2ed737283e7$export$67b768ac9e1c70fa)(spawned, parsed.options, processDone);
        const stdout = $5592df8b3ad65217$var$handleOutput(parsed.options, stdoutResult);
        const stderr = $5592df8b3ad65217$var$handleOutput(parsed.options, stderrResult);
        const all = $5592df8b3ad65217$var$handleOutput(parsed.options, allResult);
        if (error || exitCode !== 0 || signal !== null) {
            const returnedError = (0, $e3e9af5a865661d4$export$5a4bb2b1c89bdce7)({
                error: error,
                exitCode: exitCode,
                signal: signal,
                stdout: stdout,
                stderr: stderr,
                all: all,
                command: command,
                escapedCommand: escapedCommand,
                parsed: parsed,
                timedOut: timedOut,
                isCanceled: context.isCanceled || (parsed.options.signal ? parsed.options.signal.aborted : false),
                killed: spawned.killed
            });
            if (!parsed.options.reject) return returnedError;
            throw returnedError;
        }
        return {
            command: command,
            escapedCommand: escapedCommand,
            exitCode: 0,
            stdout: stdout,
            stderr: stderr,
            all: all,
            failed: false,
            timedOut: false,
            isCanceled: false,
            killed: false
        };
    };
    const handlePromiseOnce = (0, $8f2127b429579d4b$export$2e2bcd8739ae039)(handlePromise);
    (0, $74dcc2ed737283e7$export$412508d679148d5c)(spawned, parsed.options);
    spawned.all = (0, $74dcc2ed737283e7$export$41f5c0c12dadd6ae)(spawned, parsed.options);
    (0, $dc8d3fb88008b965$export$14becf8d91886424)(spawned);
    (0, $8bc863ccfadd07ed$export$e6eb0007fd542aba)(spawned, handlePromiseOnce);
    return spawned;
}
function $5592df8b3ad65217$export$28823a701bb5a12d(file, args, options) {
    const parsed = $5592df8b3ad65217$var$handleArguments(file, args, options);
    const command = (0, $12926dfec523da61$export$ab3db8fe5ebf3a1)(file, args);
    const escapedCommand = (0, $12926dfec523da61$export$9d3099014bd914f8)(file, args);
    (0, $f489e9cc4200146e$export$3bb886c4c1352118)(escapedCommand, parsed.options);
    const input = (0, $74dcc2ed737283e7$export$7f2f9b6457412b41)(parsed.options);
    let result;
    try {
        result = (0, $iIEVR$nodechild_process).spawnSync(parsed.file, parsed.args, {
            ...parsed.options,
            input: input
        });
    } catch (error) {
        throw (0, $e3e9af5a865661d4$export$5a4bb2b1c89bdce7)({
            error: error,
            stdout: "",
            stderr: "",
            all: "",
            command: command,
            escapedCommand: escapedCommand,
            parsed: parsed,
            timedOut: false,
            isCanceled: false,
            killed: false
        });
    }
    const stdout = $5592df8b3ad65217$var$handleOutput(parsed.options, result.stdout, result.error);
    const stderr = $5592df8b3ad65217$var$handleOutput(parsed.options, result.stderr, result.error);
    if (result.error || result.status !== 0 || result.signal !== null) {
        const error = (0, $e3e9af5a865661d4$export$5a4bb2b1c89bdce7)({
            stdout: stdout,
            stderr: stderr,
            error: result.error,
            signal: result.signal,
            exitCode: result.status,
            command: command,
            escapedCommand: escapedCommand,
            parsed: parsed,
            timedOut: result.error && result.error.code === "ETIMEDOUT",
            isCanceled: false,
            killed: result.signal !== null
        });
        if (!parsed.options.reject) return error;
        throw error;
    }
    return {
        command: command,
        escapedCommand: escapedCommand,
        exitCode: 0,
        stdout: stdout,
        stderr: stderr,
        failed: false,
        timedOut: false,
        isCanceled: false,
        killed: false
    };
}
const $5592df8b3ad65217$var$normalizeScriptStdin = ({ input: input, inputFile: inputFile, stdio: stdio })=>input === undefined && inputFile === undefined && stdio === undefined ? {
        stdin: "inherit"
    } : {};
const $5592df8b3ad65217$var$normalizeScriptOptions = (options = {})=>({
        preferLocal: true,
        ...$5592df8b3ad65217$var$normalizeScriptStdin(options),
        ...options
    });
function $5592df8b3ad65217$var$create$(options) {
    function $(templatesOrOptions, ...expressions) {
        if (!Array.isArray(templatesOrOptions)) return $5592df8b3ad65217$var$create$({
            ...options,
            ...templatesOrOptions
        });
        const [file, ...args] = (0, $12926dfec523da61$export$4a6ee54de9b0f25d)(templatesOrOptions, expressions);
        return $5592df8b3ad65217$export$db6b1668e3758717(file, args, $5592df8b3ad65217$var$normalizeScriptOptions(options));
    }
    $.sync = (templates, ...expressions)=>{
        if (!Array.isArray(templates)) throw new TypeError("Please use $(options).sync`command` instead of $.sync(options)`command`.");
        const [file, ...args] = (0, $12926dfec523da61$export$4a6ee54de9b0f25d)(templates, expressions);
        return $5592df8b3ad65217$export$28823a701bb5a12d(file, args, $5592df8b3ad65217$var$normalizeScriptOptions(options));
    };
    return $;
}
const $5592df8b3ad65217$export$3d8c2f653ac9d0b9 = $5592df8b3ad65217$var$create$();
function $5592df8b3ad65217$export$eb9ed1222071f2f6(command, options) {
    const [file, ...args] = (0, $12926dfec523da61$export$78bcee23e0849f6a)(command);
    return $5592df8b3ad65217$export$db6b1668e3758717(file, args, options);
}
function $5592df8b3ad65217$export$5c60dbe76a54db4(command, options) {
    const [file, ...args] = (0, $12926dfec523da61$export$78bcee23e0849f6a)(command);
    return $5592df8b3ad65217$export$28823a701bb5a12d(file, args, options);
}
function $5592df8b3ad65217$export$c004ac68fdb98119(scriptPath, args, options = {}) {
    if (args && !Array.isArray(args) && typeof args === "object") {
        options = args;
        args = [];
    }
    const stdio = (0, $393723fe1aa3d025$export$889423b478ae2ba)(options);
    const defaultExecArgv = (0, $iIEVR$nodeprocess).execArgv.filter((arg)=>!arg.startsWith("--inspect"));
    const { nodePath: nodePath = (0, $iIEVR$nodeprocess).execPath, nodeOptions: nodeOptions = defaultExecArgv } = options;
    return $5592df8b3ad65217$export$db6b1668e3758717(nodePath, [
        ...nodeOptions,
        scriptPath,
        ...Array.isArray(args) ? args : []
    ], {
        ...options,
        stdin: undefined,
        stdout: undefined,
        stderr: undefined,
        stdio: stdio,
        shell: false
    });
}


function $345f0b38609981b6$export$7683bf1311d8252() {
    return (0, (/*@__PURE__*/$parcel$interopDefault($2a4ec6ee800b4c3d$exports))).sync("sudo", {
        nothrow: true
    }) !== null;
}
function $345f0b38609981b6$export$e3140dc7d0c35e48() {
    // TODO not all CI systems are root
    return process.getuid?.() === 0 || Boolean(process.env.CI);
}
function $345f0b38609981b6$export$316200228f28b8ce() {
    return $345f0b38609981b6$export$e3140dc7d0c35e48() && $345f0b38609981b6$export$7683bf1311d8252();
}
function $345f0b38609981b6$export$d976d47922ae9667(command) {
    if ($345f0b38609981b6$export$316200228f28b8ce()) return `sudo ${command}`;
    return command;
}
const $345f0b38609981b6$export$151aeb0ade3989e1 = {
    stdio: "inherit",
    shell: true
};
function $345f0b38609981b6$export$58f152936f209932(program, args = [], execOptions = $345f0b38609981b6$export$151aeb0ade3989e1) {
    if ($345f0b38609981b6$export$316200228f28b8ce()) {
        const command = $345f0b38609981b6$var$getSudoCommand(program, args);
        return (0, $5592df8b3ad65217$export$5c60dbe76a54db4)(command, execOptions);
    } else return (0, $5592df8b3ad65217$export$28823a701bb5a12d)(program, $345f0b38609981b6$var$quote(args), execOptions);
}
function $345f0b38609981b6$export$351270479e2eef26(program, args = [], execOptions = $345f0b38609981b6$export$151aeb0ade3989e1) {
    if ($345f0b38609981b6$export$316200228f28b8ce()) {
        const command = $345f0b38609981b6$var$getSudoCommand(program, args);
        return (0, $5592df8b3ad65217$export$eb9ed1222071f2f6)(command, execOptions);
    } else return (0, $5592df8b3ad65217$export$db6b1668e3758717)(program, $345f0b38609981b6$var$quote(args), execOptions);
}
function $345f0b38609981b6$var$getSudoCommand(program, args) {
    return `sudo ${$345f0b38609981b6$var$quote([
        program,
        ...args
    ]).join(" ")}`;
}
function $345f0b38609981b6$var$quote(strings) {
    return strings.map((str)=>`'${str}'`);
} //# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicm9vdC5tanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJzcmMvcm9vdC5tdHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxLQUFLLE1BQU0sT0FBTyxDQUFBO0FBQ3pCLE9BQU8sRUFDTCxLQUFLLEVBQ0wsWUFBWSxFQUNaLGdCQUFnQixFQUNoQixTQUFTLEdBS1YsTUFBTSxPQUFPLENBQUE7QUFFZCxrQ0FBa0M7QUFDbEMsTUFBTSxVQUFVLE9BQU87SUFDckIsT0FBTyxLQUFLLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRSxFQUFFLE9BQU8sRUFBRSxJQUFJLEVBQUUsQ0FBQyxLQUFLLElBQUksQ0FBQTtBQUN2RCxDQUFDO0FBRUQ7Ozs7Ozs7Ozs7Ozs7R0FhRztBQUNILE1BQU0sVUFBVSxNQUFNO0lBQ3BCLG1DQUFtQztJQUNuQyxPQUFPLE9BQU8sQ0FBQyxNQUFNLEVBQUUsRUFBRSxLQUFLLENBQUMsSUFBSSxPQUFPLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQTtBQUM1RCxDQUFDO0FBRUQsbUVBQW1FO0FBQ25FLE1BQU0sVUFBVSxNQUFNO0lBQ3BCLE9BQU8sTUFBTSxFQUFFLElBQUksT0FBTyxFQUFFLENBQUE7QUFDOUIsQ0FBQztBQUVELHlEQUF5RDtBQUN6RCxNQUFNLFVBQVUsV0FBVyxDQUFDLE9BQWU7SUFDekMsSUFBSSxNQUFNLEVBQUUsRUFBRSxDQUFDO1FBQ2IsT0FBTyxRQUFRLE9BQU8sRUFBRSxDQUFBO0lBQzFCLENBQUM7SUFDRCxPQUFPLE9BQU8sQ0FBQTtBQUNoQixDQUFDO0FBRUQsK0RBQStEO0FBQy9ELE1BQU0sQ0FBQyxNQUFNLGtCQUFrQixHQUFxQixFQUFFLEtBQUssRUFBRSxTQUFTLEVBQUUsS0FBSyxFQUFFLElBQUksRUFBRSxDQUFBO0FBRXJGOzs7Ozs7O0dBT0c7QUFDSCxNQUFNLFVBQVUsWUFBWSxDQUMxQixPQUFlLEVBQ2YsT0FBaUIsRUFBRSxFQUNuQixjQUFnQyxrQkFBa0I7SUFFbEQsSUFBSSxNQUFNLEVBQUUsRUFBRSxDQUFDO1FBQ2IsTUFBTSxPQUFPLEdBQUcsY0FBYyxDQUFDLE9BQU8sRUFBRSxJQUFJLENBQUMsQ0FBQTtRQUM3QyxPQUFPLGdCQUFnQixDQUFDLE9BQU8sRUFBRSxXQUFXLENBQUMsQ0FBQTtJQUMvQyxDQUFDO1NBQU0sQ0FBQztRQUNOLE9BQU8sU0FBUyxDQUFDLE9BQU8sRUFBRSxLQUFLLENBQUMsSUFBSSxDQUFDLEVBQUUsV0FBVyxDQUFDLENBQUE7SUFDckQsQ0FBQztBQUNILENBQUM7QUFFRDs7Ozs7OztHQU9HO0FBQ0gsTUFBTSxVQUFVLFFBQVEsQ0FDdEIsT0FBZSxFQUNmLE9BQWlCLEVBQUUsRUFDbkIsY0FBNEIsa0JBQWtCO0lBRTlDLElBQUksTUFBTSxFQUFFLEVBQUUsQ0FBQztRQUNiLE1BQU0sT0FBTyxHQUFHLGNBQWMsQ0FBQyxPQUFPLEVBQUUsSUFBSSxDQUFDLENBQUE7UUFDN0MsT0FBTyxZQUFZLENBQUMsT0FBTyxFQUFFLFdBQVcsQ0FBQyxDQUFBO0lBQzNDLENBQUM7U0FBTSxDQUFDO1FBQ04sT0FBTyxLQUFLLENBQUMsT0FBTyxFQUFFLEtBQUssQ0FBQyxJQUFJLENBQUMsRUFBRSxXQUFXLENBQUMsQ0FBQTtJQUNqRCxDQUFDO0FBQ0gsQ0FBQztBQUVELFNBQVMsY0FBYyxDQUFDLE9BQWUsRUFBRSxJQUFjO0lBQ3JELE9BQU8sUUFBUSxLQUFLLENBQUMsQ0FBQyxPQUFPLEVBQUUsR0FBRyxJQUFJLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFBO0FBQ3RELENBQUM7QUFFRCxTQUFTLEtBQUssQ0FBQyxPQUFpQjtJQUM5QixPQUFPLE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLEVBQUUsRUFBRSxDQUFDLElBQUksR0FBRyxHQUFHLENBQUMsQ0FBQTtBQUN6QyxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHdoaWNoIGZyb20gXCJ3aGljaFwiXG5pbXBvcnQge1xuICBleGVjYSxcbiAgZXhlY2FDb21tYW5kLFxuICBleGVjYUNvbW1hbmRTeW5jLFxuICBleGVjYVN5bmMsXG4gIFN5bmNPcHRpb25zIGFzIEV4ZWNhU3luY09wdGlvbnMsXG4gIEV4ZWNhU3luY1JldHVyblZhbHVlLFxuICBPcHRpb25zIGFzIEV4ZWNhT3B0aW9ucyxcbiAgRXhlY2FDaGlsZFByb2Nlc3MsXG59IGZyb20gXCJleGVjYVwiXG5cbi8qKiBEZXRlY3QgaWYgc3VkbyBpcyBhdmFpbGFibGUgKi9cbmV4cG9ydCBmdW5jdGlvbiBoYXNTdWRvKCk6IGJvb2xlYW4ge1xuICByZXR1cm4gd2hpY2guc3luYyhcInN1ZG9cIiwgeyBub3Rocm93OiB0cnVlIH0pICE9PSBudWxsXG59XG5cbi8qKlxuICogRGV0ZWN0IGlmIHRoZSBwcm9jZXNzIGhhcyByb290IHByaXZpbGVnZSBvbiBQb3NpeC5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYGpzXG4gKiBpbXBvcnQgeyBpc1Jvb3QgfSBmcm9tIFwiYWRtaW5hXCJcbiAqXG4gKiBjb25zb2xlLmxvZyhpc1Jvb3QoKSlcbiAqIC8vPT4gZmFsc2VcbiAqIGBgYFxuICpcbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIHByb2Nlc3MgaXMgcnVubmluZyBhcyByb290LlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNSb290KCk6IGJvb2xlYW4ge1xuICAvLyBUT0RPIG5vdCBhbGwgQ0kgc3lzdGVtcyBhcmUgcm9vdFxuICByZXR1cm4gcHJvY2Vzcy5nZXR1aWQ/LigpID09PSAwIHx8IEJvb2xlYW4ocHJvY2Vzcy5lbnYuQ0kpXG59XG5cbi8qKiBEZXRlY3QgaWYgc3VkbyBpcyBhdmFpbGFibGUgYW5kIHRoZSB1c2VyIGhhcyByb290IHByaXZpbGVnZXMgKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1N1ZG8oKTogYm9vbGVhbiB7XG4gIHJldHVybiBpc1Jvb3QoKSAmJiBoYXNTdWRvKClcbn1cblxuLyoqIFByZXBlbmQgYHN1ZG9gIHRvIHRoZSBjb21tYW5kIGlmIHN1ZG8gaXMgYXZhaWxhYmxlICovXG5leHBvcnQgZnVuY3Rpb24gcHJlcGVuZFN1ZG8oY29tbWFuZDogc3RyaW5nKSB7XG4gIGlmIChpc1N1ZG8oKSkge1xuICAgIHJldHVybiBgc3VkbyAke2NvbW1hbmR9YFxuICB9XG4gIHJldHVybiBjb21tYW5kXG59XG5cbi8qKiBEZWZhdWx0IGV4ZWMgb3B0aW9ucyBgeyBzdGRpbzogXCJpbmhlcml0XCIsIHNoZWxsOiB0cnVlIH1gICovXG5leHBvcnQgY29uc3QgZGVmYXVsdEV4ZWNPcHRpb25zOiBFeGVjYVN5bmNPcHRpb25zID0geyBzdGRpbzogXCJpbmhlcml0XCIsIHNoZWxsOiB0cnVlIH1cblxuLyoqXG4gKiBFeGVjdXRlIGEgY29tbWFuZCBhcyByb290IGlmIHN1ZG8gaXMgYXZhaWxhYmxlLiBPdGhlcndpc2UgZXhlY3V0ZXMgdGhlIGNvbW1hbmQgbm9ybWFsbHkgd2l0aG91dCBzdWRvLlxuICpcbiAqIEBwYXJhbSBwcm9ncmFtIFRoZSBwcm9ncmFtIHRvIHNwYXduXG4gKiBAcGFyYW0gYXJncyBUaGUgY29tbWFuZCBhcmd1bWVudHNcbiAqIEBwYXJhbSBleGVjT3B0aW9ucyBUaGUgb3B0aW9ucyBwYXNzZWQgdG8gYGV4ZWNhYC4gRGVmYXVsdHMgdG8gYHsgc3RkaW86IFwiaW5oZXJpdFwiLCBzaGVsbDogdHJ1ZSB9YFxuICogQHJldHVybnMgVGhlIGV4ZWN1dGlvbiByZXN1bHRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGV4ZWNSb290U3luYyhcbiAgcHJvZ3JhbTogc3RyaW5nLFxuICBhcmdzOiBzdHJpbmdbXSA9IFtdLFxuICBleGVjT3B0aW9uczogRXhlY2FTeW5jT3B0aW9ucyA9IGRlZmF1bHRFeGVjT3B0aW9ucyxcbik6IEV4ZWNhU3luY1JldHVyblZhbHVlPHN0cmluZz4ge1xuICBpZiAoaXNTdWRvKCkpIHtcbiAgICBjb25zdCBjb21tYW5kID0gZ2V0U3Vkb0NvbW1hbmQocHJvZ3JhbSwgYXJncylcbiAgICByZXR1cm4gZXhlY2FDb21tYW5kU3luYyhjb21tYW5kLCBleGVjT3B0aW9ucylcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZXhlY2FTeW5jKHByb2dyYW0sIHF1b3RlKGFyZ3MpLCBleGVjT3B0aW9ucylcbiAgfVxufVxuXG4vKipcbiAqIEFzeW5jaHJvbm91c2x5IGV4ZWN1dGUgYSBjb21tYW5kIGFzIHJvb3QgaWYgc3VkbyBpcyBhdmFpbGFibGUuIE90aGVyd2lzZSBleGVjdXRlcyB0aGUgY29tbWFuZCBub3JtYWxseSB3aXRob3V0IHN1ZG8uXG4gKlxuICogQHBhcmFtIHByb2dyYW0gVGhlIHByb2dyYW0gdG8gc3Bhd25cbiAqIEBwYXJhbSBhcmdzIFRoZSBjb21tYW5kIGFyZ3VtZW50c1xuICogQHBhcmFtIGV4ZWNPcHRpb25zIFRoZSBvcHRpb25zIHBhc3NlZCB0byBgZXhlY2FgLiBEZWZhdWx0cyB0byBgeyBzdGRpbzogXCJpbmhlcml0XCIsIHNoZWxsOiB0cnVlIH1gXG4gKiBAcmV0dXJucyBBIHByb21pc2UgdG8gdGhlIGV4ZWN1dGlvbiByZXN1bHRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGV4ZWNSb290KFxuICBwcm9ncmFtOiBzdHJpbmcsXG4gIGFyZ3M6IHN0cmluZ1tdID0gW10sXG4gIGV4ZWNPcHRpb25zOiBFeGVjYU9wdGlvbnMgPSBkZWZhdWx0RXhlY09wdGlvbnMsXG4pOiBFeGVjYUNoaWxkUHJvY2VzczxzdHJpbmc+IHtcbiAgaWYgKGlzU3VkbygpKSB7XG4gICAgY29uc3QgY29tbWFuZCA9IGdldFN1ZG9Db21tYW5kKHByb2dyYW0sIGFyZ3MpXG4gICAgcmV0dXJuIGV4ZWNhQ29tbWFuZChjb21tYW5kLCBleGVjT3B0aW9ucylcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZXhlY2EocHJvZ3JhbSwgcXVvdGUoYXJncyksIGV4ZWNPcHRpb25zKVxuICB9XG59XG5cbmZ1bmN0aW9uIGdldFN1ZG9Db21tYW5kKHByb2dyYW06IHN0cmluZywgYXJnczogc3RyaW5nW10pIHtcbiAgcmV0dXJuIGBzdWRvICR7cXVvdGUoW3Byb2dyYW0sIC4uLmFyZ3NdKS5qb2luKFwiIFwiKX1gXG59XG5cbmZ1bmN0aW9uIHF1b3RlKHN0cmluZ3M6IHN0cmluZ1tdKSB7XG4gIHJldHVybiBzdHJpbmdzLm1hcCgoc3RyKSA9PiBgJyR7c3RyfSdgKVxufVxuIl19


var $aea007f8ecc715b7$exports = {};

$parcel$export($aea007f8ecc715b7$exports, "isAdminWindows", () => $aea007f8ecc715b7$export$36ad181701cee597);
$parcel$export($aea007f8ecc715b7$exports, "isAdminPosix", () => $aea007f8ecc715b7$export$2ebf12717e6b5bb8);
$parcel$export($aea007f8ecc715b7$exports, "isAdmin", () => $aea007f8ecc715b7$export$fc970ed23da99565);
// From `is-admin`: updated execa

// https://stackoverflow.com/a/28268802
async function $1435957f18d7d822$var$testFltmc() {
    try {
        await (0, $5592df8b3ad65217$export$db6b1668e3758717)("fltmc");
        return true;
    } catch  {
        return false;
    }
}
async function $1435957f18d7d822$export$2e2bcd8739ae039() {
    if (process.platform !== "win32") return false;
    try {
        // https://stackoverflow.com/a/21295806/1641422
        await (0, $5592df8b3ad65217$export$db6b1668e3758717)("fsutil", [
            "dirty",
            "query",
            process.env.systemdrive ?? ""
        ]);
        return true;
    } catch (error) {
        if (error.code === "ENOENT") return $1435957f18d7d822$var$testFltmc();
        return false;
    }
} //# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaXMtYWRtaW4ubWpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsic3JjL2lzLWFkbWluLm10cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxpQ0FBaUM7QUFFakMsT0FBTyxFQUFFLEtBQUssRUFBRSxNQUFNLE9BQU8sQ0FBQTtBQUU3Qix1Q0FBdUM7QUFDdkMsS0FBSyxVQUFVLFNBQVM7SUFDdEIsSUFBSSxDQUFDO1FBQ0gsTUFBTSxLQUFLLENBQUMsT0FBTyxDQUFDLENBQUE7UUFDcEIsT0FBTyxJQUFJLENBQUE7SUFDYixDQUFDO0lBQUMsTUFBTSxDQUFDO1FBQ1AsT0FBTyxLQUFLLENBQUE7SUFDZCxDQUFDO0FBQ0gsQ0FBQztBQUVELE1BQU0sQ0FBQyxPQUFPLENBQUMsS0FBSyxVQUFVLE9BQU87SUFDbkMsSUFBSSxPQUFPLENBQUMsUUFBUSxLQUFLLE9BQU8sRUFBRSxDQUFDO1FBQ2pDLE9BQU8sS0FBSyxDQUFBO0lBQ2QsQ0FBQztJQUVELElBQUksQ0FBQztRQUNILCtDQUErQztRQUMvQyxNQUFNLEtBQUssQ0FBQyxRQUFRLEVBQUUsQ0FBQyxPQUFPLEVBQUUsT0FBTyxFQUFFLE9BQU8sQ0FBQyxHQUFHLENBQUMsV0FBVyxJQUFJLEVBQUUsQ0FBQyxDQUFDLENBQUE7UUFDeEUsT0FBTyxJQUFJLENBQUE7SUFDYixDQUFDO0lBQUMsT0FBTyxLQUFLLEVBQUUsQ0FBQztRQUNmLElBQUssS0FBMkIsQ0FBQyxJQUFJLEtBQUssUUFBUSxFQUFFLENBQUM7WUFDbkQsT0FBTyxTQUFTLEVBQUUsQ0FBQTtRQUNwQixDQUFDO1FBRUQsT0FBTyxLQUFLLENBQUE7SUFDZCxDQUFDO0FBQ0gsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8vIEZyb20gYGlzLWFkbWluYDogdXBkYXRlZCBleGVjYVxuXG5pbXBvcnQgeyBleGVjYSB9IGZyb20gXCJleGVjYVwiXG5cbi8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yODI2ODgwMlxuYXN5bmMgZnVuY3Rpb24gdGVzdEZsdG1jKCkge1xuICB0cnkge1xuICAgIGF3YWl0IGV4ZWNhKFwiZmx0bWNcIilcbiAgICByZXR1cm4gdHJ1ZVxuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBhc3luYyBmdW5jdGlvbiBpc0FkbWluKCkge1xuICBpZiAocHJvY2Vzcy5wbGF0Zm9ybSAhPT0gXCJ3aW4zMlwiKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICB0cnkge1xuICAgIC8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yMTI5NTgwNi8xNjQxNDIyXG4gICAgYXdhaXQgZXhlY2EoXCJmc3V0aWxcIiwgW1wiZGlydHlcIiwgXCJxdWVyeVwiLCBwcm9jZXNzLmVudi5zeXN0ZW1kcml2ZSA/PyBcIlwiXSlcbiAgICByZXR1cm4gdHJ1ZVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGlmICgoZXJyb3IgYXMgeyBjb2RlPzogc3RyaW5nIH0pLmNvZGUgPT09IFwiRU5PRU5UXCIpIHtcbiAgICAgIHJldHVybiB0ZXN0Rmx0bWMoKVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG4iXX0=



const $aea007f8ecc715b7$export$36ad181701cee597 = (0, $1435957f18d7d822$export$2e2bcd8739ae039);
const $aea007f8ecc715b7$export$2ebf12717e6b5bb8 = (0, $345f0b38609981b6$export$e3140dc7d0c35e48);
function $aea007f8ecc715b7$export$fc970ed23da99565() {
    if (process.platform === "win32") return $aea007f8ecc715b7$export$36ad181701cee597();
    else return (0, $345f0b38609981b6$export$e3140dc7d0c35e48)();
} //# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYWRtaW4ubWpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsic3JjL2FkbWluLm10cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsT0FBTyxJQUFJLGtCQUFrQixFQUFFLE1BQU0sZ0JBQWdCLENBQUE7QUFDOUQsT0FBTyxFQUFFLE1BQU0sRUFBRSxNQUFNLFlBQVksQ0FBQTtBQUVuQzs7Ozs7Ozs7Ozs7OztHQWFHO0FBQ0gsTUFBTSxDQUFDLE1BQU0sY0FBYyxHQUFHLGtCQUFrQixDQUFBO0FBRWhEOzs7Ozs7Ozs7Ozs7O0dBYUc7QUFDSCxNQUFNLENBQUMsTUFBTSxZQUFZLEdBQUcsTUFBTSxDQUFBO0FBRWxDOzs7Ozs7Ozs7Ozs7Ozs7R0FlRztBQUNILE1BQU0sVUFBVSxPQUFPO0lBQ3JCLElBQUksT0FBTyxDQUFDLFFBQVEsS0FBSyxPQUFPLEVBQUUsQ0FBQztRQUNqQyxPQUFPLGNBQWMsRUFBRSxDQUFBO0lBQ3pCLENBQUM7U0FBTSxDQUFDO1FBQ04sT0FBTyxNQUFNLEVBQUUsQ0FBQTtJQUNqQixDQUFDO0FBQ0gsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGRlZmF1bHQgYXMgaXNBZG1pbldpbmRvd3NPcmlnIH0gZnJvbSBcIi4vaXMtYWRtaW4ubWpzXCJcbmltcG9ydCB7IGlzUm9vdCB9IGZyb20gXCIuL3Jvb3QubWpzXCJcblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgcHJvY2VzcyBpcyBydW5uaW5nIGFzIGFkbWluaXN0cmF0b3Igb24gV2luZG93cy5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYGpzXG4gKiBpbXBvcnQgeyBpc0FkbWluV2luZG93cyB9IGZyb20gXCJhZG1pbmFcIlxuICpcbiAqIGNvbnNvbGUubG9nKGF3YWl0IGlzQWRtaW5XaW5kb3dzKCkpXG4gKiAvLz0+IGZhbHNlXG4gKiBgYGBcbiAqXG4gKiBAcmV0dXJucyBXaGV0aGVyIHRoZSBwcm9jZXNzIGlzIHJ1bm5pbmcgYXMgYWRtaW5pc3RyYXRvci5cbiAqL1xuZXhwb3J0IGNvbnN0IGlzQWRtaW5XaW5kb3dzID0gaXNBZG1pbldpbmRvd3NPcmlnXG5cbi8qKlxuICogRGV0ZWN0IGlmIHRoZSBwcm9jZXNzIGhhcyByb290IHByaXZpbGVnZSBvbiBQb3NpeC5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYGpzXG4gKiBpbXBvcnQgeyBpc0FkbWluUG9zaXggfSBmcm9tIFwiYWRtaW5hXCJcbiAqXG4gKiBjb25zb2xlLmxvZyhpc0FkbWluUG9zaXgoKSlcbiAqIC8vPT4gZmFsc2VcbiAqIGBgYFxuICpcbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIHByb2Nlc3MgaXMgcnVubmluZyBhcyByb290LlxuICovXG5leHBvcnQgY29uc3QgaXNBZG1pblBvc2l4ID0gaXNSb290XG5cbi8qKlxuICogRGV0ZWN0IGlmIHRoZSBjb2RlIGlzIHJ1bm5pbmcgYXMgYWRtaW4vcm9vdFxuICpcbiAqIE9uIFdpbmRvd3MsIGl0IGNoZWNrcyBmb3IgYWRtaW4gYWNjZXNzLCBhbmQgb24gUG9zaXgsIGl0IGNoZWNrcyBmb3Igcm9vdCBhY2Nlc3NcbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYGpzXG4gKiBpbXBvcnQgeyBpc0FkbWluIH0gZnJvbSBcImFkbWluYVwiXG4gKlxuICogY29uc29sZS5sb2coaXNBZG1pbigpKVxuICogLy89PiBmYWxzZVxuICogYGBgXG4gKlxuICogQHJldHVybnMgV2hldGhlciB0aGUgcHJvY2VzcyBpcyBydW5uaW5nIGFzIHJvb3Qgb3IgYWRtaW4uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0FkbWluKCkge1xuICBpZiAocHJvY2Vzcy5wbGF0Zm9ybSA9PT0gXCJ3aW4zMlwiKSB7XG4gICAgcmV0dXJuIGlzQWRtaW5XaW5kb3dzKClcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gaXNSb290KClcbiAgfVxufVxuIl19


var $628e0bd756f94a5d$exports = {};

$parcel$export($628e0bd756f94a5d$exports, "grantUserWriteAccess", () => $628e0bd756f94a5d$export$4718e061a205eab);


async function $628e0bd756f94a5d$export$4718e061a205eab(path) {
    if ((process.platform === "linux" || process.platform === "darwin") && (0, $345f0b38609981b6$export$316200228f28b8ce)() && process.env.SUDO_USER !== undefined) {
        const isDirectory = (0, $iIEVR$fs).statSync(path).isDirectory();
        await (0, $345f0b38609981b6$export$351270479e2eef26)("chown", [
            ...isDirectory ? [
                "-R"
            ] : [],
            process.env.SUDO_USER,
            path
        ], (0, $345f0b38609981b6$export$151aeb0ade3989e1));
    }
} //# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXNlci1hY2Nlc3MubWpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsic3JjL3VzZXItYWNjZXNzLm10cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsTUFBTSxFQUFFLFFBQVEsRUFBRSxrQkFBa0IsRUFBRSxNQUFNLFlBQVksQ0FBQTtBQUNqRSxPQUFPLEVBQUUsTUFBTSxJQUFJLENBQUE7QUFFbkI7Ozs7O0dBS0c7QUFDSCxNQUFNLENBQUMsS0FBSyxVQUFVLG9CQUFvQixDQUFDLElBQVk7SUFDckQsSUFDRSxDQUFDLE9BQU8sQ0FBQyxRQUFRLEtBQUssT0FBTyxJQUFJLE9BQU8sQ0FBQyxRQUFRLEtBQUssUUFBUSxDQUFDO1FBQy9ELE1BQU0sRUFBRTtRQUNSLE9BQU8sQ0FBQyxHQUFHLENBQUMsU0FBUyxLQUFLLFNBQVMsRUFDbkMsQ0FBQztRQUNELE1BQU0sV0FBVyxHQUFHLEVBQUUsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLENBQUMsV0FBVyxFQUFFLENBQUE7UUFDbkQsTUFBTSxRQUFRLENBQUMsT0FBTyxFQUFFLENBQUMsR0FBRyxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsT0FBTyxDQUFDLEdBQUcsQ0FBQyxTQUFTLEVBQUUsSUFBSSxDQUFDLEVBQUUsa0JBQWtCLENBQUMsQ0FBQTtJQUM1RyxDQUFDO0FBQ0gsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGlzU3VkbywgZXhlY1Jvb3QsIGRlZmF1bHRFeGVjT3B0aW9ucyB9IGZyb20gXCIuL3Jvb3QubWpzXCJcbmltcG9ydCBmcyBmcm9tIFwiZnNcIlxuXG4vKipcbiAqIEdpdmUgdGhlIHVzZXIgYWNjZXNzIHRvIHRoZSBnaXZlbiBwYXRoIChhbmQgaXRzIHN1Yi1kaXJlY3RvcmllcyBpZiBhIGRpcmVjdG9yeSkuIEl0IGNoYW5nZXMgdGhlIG93bmVyIHRvIHRoZVxuICogU1VET19VU0VSLiBUaGlzIGFsbG93cyB0aGUgdXNlciB0byB1c2UgdGhlIGZvbGRlciB3aXRob3V0IHN1ZG9cbiAqXG4gKiBAcGFyYW0gcGF0aCBUaGUgcGF0aCB0byBnaXZlIHRoZSB1c2VyIGFjY2VzcyB0b1xuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ3JhbnRVc2VyV3JpdGVBY2Nlc3MocGF0aDogc3RyaW5nKSB7XG4gIGlmIChcbiAgICAocHJvY2Vzcy5wbGF0Zm9ybSA9PT0gXCJsaW51eFwiIHx8IHByb2Nlc3MucGxhdGZvcm0gPT09IFwiZGFyd2luXCIpICYmXG4gICAgaXNTdWRvKCkgJiZcbiAgICBwcm9jZXNzLmVudi5TVURPX1VTRVIgIT09IHVuZGVmaW5lZFxuICApIHtcbiAgICBjb25zdCBpc0RpcmVjdG9yeSA9IGZzLnN0YXRTeW5jKHBhdGgpLmlzRGlyZWN0b3J5KClcbiAgICBhd2FpdCBleGVjUm9vdChcImNob3duXCIsIFsuLi4oaXNEaXJlY3RvcnkgPyBbXCItUlwiXSA6IFtdKSwgcHJvY2Vzcy5lbnYuU1VET19VU0VSLCBwYXRoXSwgZGVmYXVsdEV4ZWNPcHRpb25zKVxuICB9XG59XG4iXX0=


 //# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXgubWpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsic3JjL2luZGV4Lm10cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxjQUFjLFlBQVksQ0FBQTtBQUMxQixjQUFjLGFBQWEsQ0FBQTtBQUMzQixjQUFjLG1CQUFtQixDQUFBIiwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0ICogZnJvbSBcIi4vcm9vdC5tanNcIlxuZXhwb3J0ICogZnJvbSBcIi4vYWRtaW4ubWpzXCJcbmV4cG9ydCAqIGZyb20gXCIuL3VzZXItYWNjZXNzLm1qc1wiXG4iXX0=


export {$345f0b38609981b6$export$7683bf1311d8252 as hasSudo, $345f0b38609981b6$export$e3140dc7d0c35e48 as isRoot, $345f0b38609981b6$export$316200228f28b8ce as isSudo, $345f0b38609981b6$export$d976d47922ae9667 as prependSudo, $345f0b38609981b6$export$151aeb0ade3989e1 as defaultExecOptions, $345f0b38609981b6$export$58f152936f209932 as execRootSync, $345f0b38609981b6$export$351270479e2eef26 as execRoot, $aea007f8ecc715b7$export$36ad181701cee597 as isAdminWindows, $aea007f8ecc715b7$export$2ebf12717e6b5bb8 as isAdminPosix, $aea007f8ecc715b7$export$fc970ed23da99565 as isAdmin, $628e0bd756f94a5d$export$4718e061a205eab as grantUserWriteAccess};
//# sourceMappingURL=index.deno.mjs.map
